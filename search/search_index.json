{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GUITk's documentation!","text":"<p>GUITk is a declarative framework for building nice-looking, cross-platform GUIs with tkinter inspired by SwiftUI.</p> <p>GUITk allows you to build complete GUI applications with a few lines of code. GUITk makes it easy to layout your GUI elements and respond to events using a declarative syntax. Because GUITk is built on top of tkinter, you can access the underlying tkinter API if you need to but for many use cases, you can build your GUI without needing to know much about tkinter.</p> <p>GUITk apps are built by subclasses the <code>guitk.Window</code> class. Your GUI elements are layed out using a <code>guitk.HLayout</code> (horizontal layout) or <code>guitk.VLayout</code> (vertical layout) object which takes care of placing all widgets in the window using a declarative syntax. This is much simpler than using the underlying tkinter grid manager or pack geometry managers.</p> <p>GUITk is in alpha stage but is in constant development so check back frequently if this interests you or open an issue to start a conversation about what pain points this project could help you solve!</p> <p>For full documentation visit GUITk.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install guitk</code></p>"},{"location":"#source-code","title":"Source Code","text":"<p>GUITk on GitHub</p>"},{"location":"#license","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2020 Rhet Turnbull, All rights reserved.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#window","title":"Window","text":"<p>               Bases: <code>_LayoutMixin</code>, <code>_WindowBaseClass</code></p> <p>Basic Window class from which all windows are derived</p> Notes <p>Classes which inherit from window should implement handle_event, setup, and teardown as needed</p> Source code in <code>guitk/window.py</code> <pre><code>class Window(_LayoutMixin, _WindowBaseClass):\n    \"\"\"Basic Window class from which all windows are derived\n\n    Notes:\n        Classes which inherit from window should implement handle_event, setup, and teardown as needed\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: tk.Tk | None = None,\n        title: str | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        topmost: bool | None = None,\n        autoframe: bool = False,\n        theme: str | None = None,\n        tooltip: TooltipType | None = None,\n        modal: bool | None = None,\n        size: SizeType = None,\n    ):\n        # call _config then subclass's config to initialize\n        # layout, title, menu, etc.\n\n        self.autoframe = autoframe\n\n        self._config()\n        self.config()\n\n        # override any layout defaults from constructor\n        self.title: str | None = title if title is not None else self.title\n        self.padx: int | None = padx if padx is not None else self.padx\n        self.pady: int | None = pady if pady is not None else self.pady\n        self.theme: str | None = theme if theme is not None else self.theme\n        self.tooltip: TooltipType | None = (\n            tooltip if tooltip is not None else self.tooltip\n        )\n        self.modal: bool | None = modal if modal is not None else self.modal\n        self.size: SizeType = size if size is not None else self.size\n\n        self._id: int = id(self)\n        self._tk: _TKRoot = _TKRoot()\n        self._parent = parent or self._tk.root\n        self._topmost = topmost\n\n        self.window: tk.TopLevel = tk.Toplevel(self._parent)\n        self.window.title(self.title)\n        self._widgets = []\n        self._widget_by_key = {}\n\n        self._timer_events = {}\n        \"\"\" timer events that have been set by bind_timer_event, stores most recent after() id for event\"\"\"\n\n        self._timer_events_cancelled = {}\n        \"\"\" timer events that have been set by bind_timer_event but then cancelled \"\"\"\n\n        self._return_value = None\n        \"\"\" value returned from run() if set in quit() \"\"\"\n\n        self._root_menu = None\n        \"\"\" will hold root tk.Menu widget\"\"\"\n\n        self._radiobuttons = {}\n        \"\"\" will hold group name/variable for radio buttons in the window \"\"\"\n\n        self._destroyed = False\n        \"\"\" set to True when window is destroyed \"\"\"\n\n        self._mainframe = ttk.Frame(self.window, padding=\"3 3 12 12\")\n        self._mainframe.grid(column=0, row=0, sticky=\"nsew\")\n        self.window.columnconfigure(0, weight=1)\n        self.window.rowconfigure(0, weight=1)\n\n        self._tk.register(self)\n        self.window.protocol(\n            \"WM_DELETE_WINDOW\",\n            self._make_callback(Event(self, self, EventType.Quit, EventType.Quit)),\n        )\n\n        if not self.layout:\n            self.layout = [\n                [\n                    Label(\n                        \"Looks like you forgot to include a layout in your class definition\"\n                    )\n                ]\n            ]\n\n        self._commands = []\n\n        self._layout(self._mainframe, self)\n\n        # apply theme if necessary\n        if self.theme is not None:\n            self._tk.theme = self.theme\n\n        self._grid_configure_widgets()\n\n        if self.menu:\n            self._build_menu()\n\n        if self._topmost or self.modal:\n            self.window.attributes(\"-topmost\", 1)\n\n        if self.modal:\n            windowingsystem = self.root.call(\"tk\", \"windowingsystem\")\n            if windowingsystem == \"aqua\":\n                with contextlib.suppress(Exception):\n                    self.root.call(\n                        \"::tk::unsupported::MacWindowStyle\",\n                        \"style\",\n                        self._w,\n                        \"moveableModal\",\n                        \"\",\n                    )\n            if self._parent is not None and self._parent.winfo_viewable():\n                self.window.transient(self._parent)\n            self.window.wait_visibility()\n            self.window.grab_set()\n\n        if self.size is not None:\n            size = (\n                self.size\n                if isinstance(self.size, str)\n                else f\"{self.size[0]}x{self.size[1]}\"\n            )\n            self.window.geometry(size)\n\n        # TODO: add geometry code to ensure window appears in good spot relative to parent\n\n        # setup event handling\n        self.events = True\n        self._bind_timer_event(\n            100, EventType.WindowFinishedLoading.value, EventType.WindowFinishedLoading\n        )\n        self._bind_event_handlers()\n        self._create_setup_teardown_events()\n\n        self.setup()\n        self.root.event_generate(EventType.Setup.value)\n\n        if self.modal:\n            self.window.wait_window()\n\n    def _grid_configure_widgets(self):\n        \"\"\"Apply padding to all widgets in the window\"\"\"\n        # apply padding, widget padding takes precedent over window\n        for widget in self._widgets:\n            padx = widget.padx if widget.padx is not None else self.padx\n            pady = widget.pady if widget.pady is not None else self.pady\n            widget.widget.grid_configure(padx=padx, pady=pady)\n\n    def _config(self):\n        self.title = \"My Window\"\n        \"\"\"Title to display in the window's title bar \"\"\"\n\n        self.layout = []\n        \"\"\"Every class that inherits from Window must define it's own layout \"\"\"\n\n        self.menu: MenuBar | None = None\n        \"\"\" Optionally provide a menu \"\"\"\n\n        self.padx = DEFAULT_PADX\n        self.pady = DEFAULT_PADY\n        \"\"\"Default padding around widgets \"\"\"\n\n        self.theme = None\n        \"\"\"The ttk theme to use, if None, uses ttk default\"\"\"\n\n        self.tooltip = None\n        \"\"\" A callable which returns the tooltip text for a given key or a str \"\"\"\n\n        self.modal = False\n        \"\"\" Set to True to create modal window \"\"\"\n\n        self.size = None\n        \"\"\" Set to a tuple of (width, height) to set the window size \"\"\"\n\n        push_parent(self)\n\n    def config(self):\n        pass\n\n    def handle_event(self, event: Event):\n        \"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n        ...\n        # if event.event_type == EventType.Quit:\n        # self.quit(self._return_value)\n\n    def setup(self):\n        \"\"\"Perform any needed setup for the window.\n        Gets called immediately after __init__\n        \"\"\"\n        pass\n\n    def teardown(self):\n        \"\"\"Perform any cleanup before the window closes.\n        Gets called immediately before the window is destroyed\n        \"\"\"\n        pass\n\n    @debug_watch\n    def quit(self, return_value: Any = None):\n        \"\"\"Called when closing the window\"\"\"\n        # set return value which is returned by run()\n        self._return_value = return_value\n        self._destroy()\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        self._title = value\n\n    @property\n    def geometry(self):\n        return self.size\n\n    @geometry.setter\n    def geometry(self, value):\n        self.size = value\n\n    def bind_command(self, key=None, event_type=None, command=None):\n        if not any([key, event_type]):\n            raise ValueError(\"At least one of key, event_type must be specified\")\n        self._bind_command(\n            EventCommand(widget=None, key=key, event_type=event_type, command=command)\n        )\n\n    def _bind_command(self, event_command: EventCommand):\n        self._commands.append(event_command)\n\n    def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n        \"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n        repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n        if command:\n            self.bind_command(\n                key=event_name, event_type=EventType.VirtualEvent, command=command\n            )\n        return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n\n    def _bind_timer_event(self, delay, event_name, event_type, repeat=False):\n        # create a unique name for the timer\n        timer_id = f\"{event_name}_{time.time_ns()}\"\n\n        # callback that generates event and respawns the timer if repeat=True\n        # when cancelling with cancel_timer_event, sometimes the call to after_cancel doesn't apparently work so check\n        # if timer_id is in _timer_events_cancelled before respawning\n        def _generate_event():\n            self.root.event_generate(event_name)\n            if repeat and timer_id not in self._timer_events_cancelled:\n                self._timer_events[timer_id] = self._tk.root.after(\n                    delay, _generate_event\n                )\n\n        event = Event(self, self, event_name, event_type)\n        self.root.bind(event_name, self._make_callback(event))\n        self._timer_events[timer_id] = self._tk.root.after(delay, _generate_event)\n        return timer_id\n\n    def _create_setup_teardown_events(self):\n        \"\"\"Create the setup and teardown events\"\"\"\n        setup_event = Event(self, self, EventType.Setup.value, EventType.Setup)\n        self.root.bind(EventType.Setup.value, self._make_callback(setup_event))\n\n        teardown_event = Event(self, self, EventType.Teardown.value, EventType.Teardown)\n        self.root.bind(EventType.Teardown.value, self._make_callback(teardown_event))\n\n    def cancel_timer_event(self, timer_id):\n        \"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n        try:\n            after_id = self._timer_events[timer_id]\n            self.root.after_cancel(after_id)\n            self._timer_events.pop(timer_id)\n            self._timer_events_cancelled[timer_id] = after_id\n        except KeyError as e:\n            raise ValueError(f\"Timer event {timer_id} not found\") from e\n        except Exception as e:\n            raise e\n\n    def _bind_event_handlers(self):\n        \"\"\"Bind any event handlers decorated with @on\"\"\"\n        for method in self.__class__.__dict__.values():\n            if hasattr(method, \"_guitk_event_handlers\"):\n                for key, event_type in getattr(method, \"_guitk_event_handlers\"):\n                    self.bind_command(key=key, event_type=event_type, command=method)\n\n    def add_widget(self, widget: BaseWidget, row: int, col: int):\n        \"\"\"Add a widget to the window's mainframe\"\"\"\n        widget._create_widget(self._mainframe, self, row, col)\n        self._widgets.append(widget)\n        self._widget_by_key[widget.key] = widget\n        self._grid_configure_widgets()\n\n    def remove(self, key_or_widget: Hashable | BaseWidget):\n        \"\"\"Remove widget from window and destroy it.\"\"\"\n        for idx, widget in enumerate(self._widgets):\n            debug(f\"{idx=} {widget=} {key_or_widget=}\")\n            if widget == key_or_widget or widget.key == key_or_widget:\n                widget = self._widgets[idx]\n                if widget.parent == self:\n                    self._remove(widget)\n                else:\n                    widget.parent.remove(widget)\n                return\n        raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n\n    def _remove(self, widget: BaseWidget):\n        \"\"\"Remove widget from window and destroy it.\"\"\"\n        widget.widget.grid_forget()\n        widget.widget.destroy()\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n        self.window.update_idletasks()\n\n    def _insert_widget_row_col(self, widget: BaseWidget, row: int, col: int):\n        \"\"\"Insert a widget into the window's mainframe after the container has been created\n            Intended for use at run-time only when widgets need to be added dynamically\n\n        Args:\n            widget: (Widget) the widget to add\n            row: (int) the row to insert the widget into\n            col: (int) the column to insert the widget into\n\n        Note:\n            This method is included in Window so that Widget.replace() works properly for\n            widgets added directly to a layout. It does not expand the layout like the similar\n            method in _Container.\n        \"\"\"\n        # TODO: fix this so it actually inserts instead of replaces\n        self.add_widget(widget, row, col)\n\n    def run(self):\n        self._tk.run_mainloop()\n        return self._return_value\n\n    @property\n    def root(self):\n        \"\"\"Return Tk root instance\"\"\"\n        return self._tk.root\n\n    @property\n    def widgets(self) -&gt; list[BaseWidget]:\n        \"\"\" \"Return list of all widgets belonging to the window\"\"\"\n        return self._widgets\n\n    def children(self):\n        \"\"\"Return child windows\"\"\"\n        return self._tk.get_children(self)\n\n    def get(self, key: Hashable) -&gt; BaseWidget:\n        \"\"\"Get widget with key or raise KeyError if not found\"\"\"\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Widget with key {key} not found\") from e\n\n    def _add_widget(self, widget: BaseWidget):\n        \"\"\"Dummy method to allow widgets to be added with VLayout()/HLayout()\"\"\"\n        pass\n\n    def _forget_widget(self, widget: BaseWidget):\n        \"\"\"Remove widget from the window's bookkeeping but don't destroy it\"\"\"\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n\n    def _add_menus(self, menu: Menu, path: str | None = None):\n        \"\"\"Add menus to the window recursively\n\n        Args:\n            menu (Menu): the Menu object to add\n            path (str, optional): the path to the menu item which is used as the key\n        \"\"\"\n        path = f\"{MENU_MARKER}{menu._label}\" if path is None else path\n        for m in menu:\n            subpath = f\"{path}|{m._label}\"\n            m._create_widget(menu._menu, self, subpath)\n            self._widgets.append(m)\n            self._widget_by_key[m.key] = m\n            if isinstance(m, Menu):\n                self._add_menus(m, subpath)\n\n    def _build_menu(self):\n        \"\"\"Build the menu bar\"\"\"\n        if self._root_menu is None:\n            # create the root menu\n            self.root.option_add(\"*tearOff\", tk.FALSE)\n            self._root_menu = tk.Menu(self.root)\n            self.window[\"menu\"] = self._root_menu\n\n        for m in self.menu:\n            if not isinstance(m, Menu):\n                raise ValueError(\"self.menu items must be Menu objects\")\n            path = f\"{MENU_MARKER}{m._label}\"\n            m._create_widget(self._root_menu, self, path)\n            self._widgets.append(m)\n            self._widget_by_key[m.key] = m\n            self._add_menus(m, path)\n\n    @debug_watch\n    def _destroy(self):\n        \"\"\"Destroy the window and all child windows and perform cleanup\"\"\"\n        if self._destroyed:\n            # HACK: avoid multiple calls to _destroy which can occur if\n            # the user handles the Quit event themselves\n            # TODO: find a better way to handle this\n            return\n\n        # call teardown to perform any cleanup\n        self.teardown()\n\n        # generate a Teardown event\n        self.root.event_generate(EventType.Teardown.value)\n\n        # kill any child windows\n        for child in self.children():\n            event = Event(child, child.window, EventType.Quit, EventType.Quit)\n            child.handle_event(event)\n            with contextlib.suppress(Exception):\n                child._destroy()\n\n        # disable event processing in _handle_event\n        self.events = False\n\n        # disable any stdout/stderr redirection and event handling\n        for widget in self._widgets:\n            widget.events = False\n\n            if \"guitk.widgets.tk_text.Output\" in str(type(widget)):\n                widget.disable_redirect()\n\n        if self.modal:\n            self.window.grab_release()\n\n        # cancel any timer events\n        for timer_id in self._timer_events:\n            with contextlib.suppress(Exception):\n                after_id = self._timer_events[timer_id]\n                self._tk.root.after_cancel(after_id)\n        self._parent.focus_set()\n        self.window.destroy()\n        self._tk.deregister(self)\n        self._destroyed = True\n\n    def _make_callback(self, event):\n        def _callback(*arg):\n            if arg:\n                event.event = arg[0]\n            self._handle_event(event)\n\n        return _callback\n\n    @debug_watch\n    def _handle_event(self, event: Event):\n        \"\"\"Handle events for this window\"\"\"\n        # only handle events if widget has events=True; Window objects always get events\n        if isinstance(event.widget, (BaseWidget, Window)) and not event.widget.events:\n            return\n\n        # filter events for this window\n        if event.id != self._id:\n            return\n\n        # swallow MenuCommand events if the menu is disabled\n        # if event.event_type == EventType.MenuCommand and not self.menu.enabled:\n\n        # handle custom commands\n        self._handle_commands(event)\n\n        # call subclass handle_event\n        self.handle_event(event)\n\n        # if deleting the window, call _destroy after handle_event has had a chance to handle it\n        if event.event_type == EventType.Quit:\n            self._destroy()\n\n    @debug_watch\n    def _handle_commands(self, event):\n        \"\"\"Handle commands bound to widgets in the window\"\"\"\n        for command in self._commands:\n            if (\n                (command.widget is None or command.widget == event.widget)\n                and (command.key is None or command.key == event.key)\n                and (\n                    command.event_type is None or command.event_type == event.event_type\n                )\n            ) or command.event_type == EventType.Any:\n                if hasattr(command.command, \"_guitk_event_handlers\"):\n                    # command was decorated with @on, so it's a method of this class\n                    if len(inspect.signature(command.command).parameters) == 2:\n                        # command has a second argument, assume it's the event\n                        command.command(self, event)\n                    else:\n                        command.command(self)\n                else:\n                    command.command()\n\n    def __getitem__(self, key) -&gt; BaseWidget:\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Invalid key: no widget with key {key}\") from e\n</code></pre>"},{"location":"reference/#guitk.Window.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return Tk root instance</p>"},{"location":"reference/#guitk.Window.widgets","title":"<code>widgets: list[BaseWidget]</code>  <code>property</code>","text":"<p>\"Return list of all widgets belonging to the window</p>"},{"location":"reference/#guitk.Window.add_widget","title":"<code>add_widget(widget, row, col)</code>","text":"<p>Add a widget to the window's mainframe</p> Source code in <code>guitk/window.py</code> <pre><code>def add_widget(self, widget: BaseWidget, row: int, col: int):\n    \"\"\"Add a widget to the window's mainframe\"\"\"\n    widget._create_widget(self._mainframe, self, row, col)\n    self._widgets.append(widget)\n    self._widget_by_key[widget.key] = widget\n    self._grid_configure_widgets()\n</code></pre>"},{"location":"reference/#guitk.Window.bind_timer_event","title":"<code>bind_timer_event(delay, event_name, repeat=False, command=None)</code>","text":"<p>Create a new virtual event <code>event_name</code> that fires after <code>delay</code> ms, repeats every <code>delay</code> ms if repeat=True, otherwise fires once</p> Source code in <code>guitk/window.py</code> <pre><code>def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n    \"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n    repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n    if command:\n        self.bind_command(\n            key=event_name, event_type=EventType.VirtualEvent, command=command\n        )\n    return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n</code></pre>"},{"location":"reference/#guitk.Window.cancel_timer_event","title":"<code>cancel_timer_event(timer_id)</code>","text":"<p>Cancel a timer event created with bind_timer_event</p> Source code in <code>guitk/window.py</code> <pre><code>def cancel_timer_event(self, timer_id):\n    \"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n    try:\n        after_id = self._timer_events[timer_id]\n        self.root.after_cancel(after_id)\n        self._timer_events.pop(timer_id)\n        self._timer_events_cancelled[timer_id] = after_id\n    except KeyError as e:\n        raise ValueError(f\"Timer event {timer_id} not found\") from e\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"reference/#guitk.Window.children","title":"<code>children()</code>","text":"<p>Return child windows</p> Source code in <code>guitk/window.py</code> <pre><code>def children(self):\n    \"\"\"Return child windows\"\"\"\n    return self._tk.get_children(self)\n</code></pre>"},{"location":"reference/#guitk.Window.get","title":"<code>get(key)</code>","text":"<p>Get widget with key or raise KeyError if not found</p> Source code in <code>guitk/window.py</code> <pre><code>def get(self, key: Hashable) -&gt; BaseWidget:\n    \"\"\"Get widget with key or raise KeyError if not found\"\"\"\n    try:\n        return self._widget_by_key[key]\n    except KeyError as e:\n        raise KeyError(f\"Widget with key {key} not found\") from e\n</code></pre>"},{"location":"reference/#guitk.Window.handle_event","title":"<code>handle_event(event)</code>","text":"<p>Handle event objects, inheriting classes should implement handle_event</p> Source code in <code>guitk/window.py</code> <pre><code>def handle_event(self, event: Event):\n    \"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#guitk.Window.quit","title":"<code>quit(return_value=None)</code>","text":"<p>Called when closing the window</p> Source code in <code>guitk/window.py</code> <pre><code>@debug_watch\ndef quit(self, return_value: Any = None):\n    \"\"\"Called when closing the window\"\"\"\n    # set return value which is returned by run()\n    self._return_value = return_value\n    self._destroy()\n</code></pre>"},{"location":"reference/#guitk.Window.remove","title":"<code>remove(key_or_widget)</code>","text":"<p>Remove widget from window and destroy it.</p> Source code in <code>guitk/window.py</code> <pre><code>def remove(self, key_or_widget: Hashable | BaseWidget):\n    \"\"\"Remove widget from window and destroy it.\"\"\"\n    for idx, widget in enumerate(self._widgets):\n        debug(f\"{idx=} {widget=} {key_or_widget=}\")\n        if widget == key_or_widget or widget.key == key_or_widget:\n            widget = self._widgets[idx]\n            if widget.parent == self:\n                self._remove(widget)\n            else:\n                widget.parent.remove(widget)\n            return\n    raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n</code></pre>"},{"location":"reference/#guitk.Window.setup","title":"<code>setup()</code>","text":"<p>Perform any needed setup for the window. Gets called immediately after init</p> Source code in <code>guitk/window.py</code> <pre><code>def setup(self):\n    \"\"\"Perform any needed setup for the window.\n    Gets called immediately after __init__\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#guitk.Window.teardown","title":"<code>teardown()</code>","text":"<p>Perform any cleanup before the window closes. Gets called immediately before the window is destroyed</p> Source code in <code>guitk/window.py</code> <pre><code>def teardown(self):\n    \"\"\"Perform any cleanup before the window closes.\n    Gets called immediately before the window is destroyed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#hlayout","title":"HLayout","text":"<p>A Layout manager that aligns widgets horizontally</p> Source code in <code>guitk/layout.py</code> <pre><code>class HLayout:\n    \"\"\"A Layout manager that aligns widgets horizontally\"\"\"\n\n    def __init__(\n        self,\n        layout: LayoutType = None,\n        *,\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n    ):\n        self._layout_list = layout or []\n        self.index = 0\n        self.valign = valign\n        self.halign = halign\n        self.window = None\n\n        # get the caller's instance so we can set the layout\n        caller_frame = currentframe().f_back\n        with contextlib.suppress(IndexError, KeyError):\n            first_arg = caller_frame.f_code.co_varnames[0]\n            caller_instance = caller_frame.f_locals[first_arg]\n            # determine if the caller is a Window\n            # need to use repr() because we can't import Window here without causing a circular import\n            if \"guitk.window.Window\" in repr(getmro(caller_instance.__class__)):\n                # HLayout is being used in a Window, so set the Window's layout automatically\n                self.window = caller_instance\n                self.window.layout = self\n\n    def append(self, widget: BaseWidget):\n        \"\"\"Add a widget to the end of the HLayout\"\"\"\n        if not self.window:\n            # HLayout is not being used in a Window, can't add widget\n            raise RuntimeError(\n                \"Layout must have been created in a Window to add widgets\"\n            )\n        self.window.col_count += 1\n        self.window.add_widget(widget, 0, self.window.col_count)\n\n    def remove(self, key_or_widget: Hashable | BaseWidget):\n        \"\"\"Remove widget from layout\" and destroy it.\n\n        Args:\n            key_or_widget (Hashable | Widget): The key or widget to remove. If a key is given,\n                the first widget with that key will be removed.\n\n        Raises:\n            RuntimeError: If called and the layout was not created in a Window.\n            ValueError: If the widget is not found in the layout.\n        \"\"\"\n        if not self.window:\n            raise RuntimeError(\n                \"Layout must have been created in a Window to remove widgets\"\n            )\n        for idx, widget in enumerate(self._layout_list):\n            if widget == key_or_widget or widget.key == key_or_widget:\n                widget = self._layout_list.pop(idx)\n                self.window._forget_widget(widget)\n                widget.widget.grid_forget()\n                widget.widget.destroy()\n                self.window.window.update_idletasks()\n                return\n        raise ValueError(f\"Widget {key_or_widget} not found in Layout\")\n\n    def _add_widget(self, widget):\n        \"\"\"Add a widget to the end of the Layout\"\"\"\n        self._layout_list.append(widget)\n\n    @property\n    def layout(self) -&gt; LayoutType:\n        \"\"\"Return the layout list\"\"\"\n        # if layout manually created, it will be a list of lists\n        # otherwise it's a row of widgets, so wrap it in a list\n        return (\n            self._layout_list\n            if self._layout_list and isinstance(self._layout_list[0], (list, tuple))\n            else [self._layout_list]\n        )\n\n    def __enter__(self):\n        push_parent(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pop_parent()\n        return False\n\n    def __iter__(self):\n        self.index = 0\n        return iter(self.layout)\n\n    def __next__(self):\n        if self.index &gt;= len(self.layout):\n            raise StopIteration\n        value = self.layout[self.index]\n        self.index += 1\n        return value\n</code></pre>"},{"location":"reference/#guitk.HLayout.layout","title":"<code>layout: LayoutType</code>  <code>property</code>","text":"<p>Return the layout list</p>"},{"location":"reference/#guitk.HLayout.append","title":"<code>append(widget)</code>","text":"<p>Add a widget to the end of the HLayout</p> Source code in <code>guitk/layout.py</code> <pre><code>def append(self, widget: BaseWidget):\n    \"\"\"Add a widget to the end of the HLayout\"\"\"\n    if not self.window:\n        # HLayout is not being used in a Window, can't add widget\n        raise RuntimeError(\n            \"Layout must have been created in a Window to add widgets\"\n        )\n    self.window.col_count += 1\n    self.window.add_widget(widget, 0, self.window.col_count)\n</code></pre>"},{"location":"reference/#guitk.HLayout.remove","title":"<code>remove(key_or_widget)</code>","text":"<p>Remove widget from layout\" and destroy it.</p> <p>Parameters:</p> Name Type Description Default <code>key_or_widget</code> <code>Hashable | Widget</code> <p>The key or widget to remove. If a key is given, the first widget with that key will be removed.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called and the layout was not created in a Window.</p> <code>ValueError</code> <p>If the widget is not found in the layout.</p> Source code in <code>guitk/layout.py</code> <pre><code>def remove(self, key_or_widget: Hashable | BaseWidget):\n    \"\"\"Remove widget from layout\" and destroy it.\n\n    Args:\n        key_or_widget (Hashable | Widget): The key or widget to remove. If a key is given,\n            the first widget with that key will be removed.\n\n    Raises:\n        RuntimeError: If called and the layout was not created in a Window.\n        ValueError: If the widget is not found in the layout.\n    \"\"\"\n    if not self.window:\n        raise RuntimeError(\n            \"Layout must have been created in a Window to remove widgets\"\n        )\n    for idx, widget in enumerate(self._layout_list):\n        if widget == key_or_widget or widget.key == key_or_widget:\n            widget = self._layout_list.pop(idx)\n            self.window._forget_widget(widget)\n            widget.widget.grid_forget()\n            widget.widget.destroy()\n            self.window.window.update_idletasks()\n            return\n    raise ValueError(f\"Widget {key_or_widget} not found in Layout\")\n</code></pre>"},{"location":"reference/#vlayout","title":"VLayout","text":"<p>               Bases: <code>HLayout</code></p> <p>A Layout manager that aligns widgets vertically</p> Source code in <code>guitk/layout.py</code> <pre><code>class VLayout(HLayout):\n    \"\"\"A Layout manager that aligns widgets vertically\"\"\"\n\n    @property\n    def layout(self):\n        return [[w] for w in self._layout_list]\n\n    def append(self, widget: BaseWidget):\n        \"\"\"Add a widget to the bottom of the VLayout\"\"\"\n        if not self.window:\n            # HLayout is not being used in a Window, can't add widget\n            raise RuntimeError(\n                \"VLayout must have been created in a Window to add widgets\"\n            )\n        self.window.row_count += 1\n        self.window.add_widget(widget, self.window.row_count, 0)\n</code></pre>"},{"location":"reference/#guitk.VLayout.append","title":"<code>append(widget)</code>","text":"<p>Add a widget to the bottom of the VLayout</p> Source code in <code>guitk/layout.py</code> <pre><code>def append(self, widget: BaseWidget):\n    \"\"\"Add a widget to the bottom of the VLayout\"\"\"\n    if not self.window:\n        # HLayout is not being used in a Window, can't add widget\n        raise RuntimeError(\n            \"VLayout must have been created in a Window to add widgets\"\n        )\n    self.window.row_count += 1\n    self.window.add_widget(widget, self.window.row_count, 0)\n</code></pre>"},{"location":"reference/#hstack","title":"HStack","text":"<p>               Bases: <code>_Stack</code></p> <p>A container that stacks widgets horizontally when added to a Layout</p> Source code in <code>guitk/containers.py</code> <pre><code>class HStack(_Stack):\n    \"\"\"A container that stacks widgets horizontally when added to a Layout\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        height: int | None = None,\n        padding: PaddingType | None = None,\n        disabled: bool | None = False,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        vexpand: bool = True,\n        hexpand: bool = True,\n        distribute: bool = False,\n        vspacing: PadType | None = None,\n        hspacing: PadType | None = None,\n        vscrollbar: bool = False,\n        # hscrollbar: bool = False,\n        autohide_scrollbars: bool = True,\n    ):\n        \"\"\"A container that stacks widgets horizontally when added to a Layout\n\n        Args:\n            key (Hashable, optional): The key to use for the HStack. Defaults to None.\n            height (int, optional): The height of the HStack. Defaults to None.\n            padding (PaddingType, optional): The padding around the HStack. Defaults to None.\n            disabled (bool, optional): Whether the HStack is disabled. Defaults to False.\n            sticky (str, optional): The sticky value for the HStack. Defaults to \"nsew\".\n            valign (VAlign, optional): The vertical alignment for the widgets in the HStack.\n                Defaults to None.\n            halign (HAlign, optional): The horizontal alignment for the widgets in the HStack.\n                Defaults to None.\n            vexpand (bool, optional): Whether the Stack should expand vertically.\n                Defaults to True.\n            hexpand (bool, optional): Whether the Stack should expand horizontally.\n                Defaults to True.\n            distribute (bool, optional): Whether the HStack should distribute widgets evenly.\n            vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n            hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n            vscrollbar (bool): Whether to include a vertical scrollbar. Defaults to False.\n            autohide_scrollbars (bool): Whether to hide scrollbars when not needed. Defaults to True.\n\n        Note:\n            If height is specified, the HStack will not expand to fill the available space and the\n            expand parameter will be ignored.\n        \"\"\"\n        super().__init__(\n            key=key,\n            height=height,\n            width=None,\n            padding=padding,\n            disabled=disabled,\n            sticky=sticky,\n            valign=valign,\n            halign=halign,\n            vexpand=vexpand,\n            hexpand=hexpand,\n            distribute=distribute,\n            vspacing=vspacing,\n            hspacing=hspacing,\n            vscrollbar=vscrollbar,\n            # hscrollbar=hscrollbar,\n            autohide_scrollbars=autohide_scrollbars,\n        )\n\n    @property\n    def layout(self) -&gt; list[list[BaseWidget]]:\n        \"\"\"Return the layout of the HStack\"\"\"\n        if self.distribute:\n            self._layout_lol = [[]]\n            for widget in self._layout_list:\n                self._layout_lol[0].append(HSpacer())\n                self._layout_lol[0].append(widget)\n            self._layout_lol[0].append(HSpacer())\n        else:\n            self._layout_lol = [self._layout_list]\n        return self._layout_lol\n\n    @layout.setter\n    def layout(self, layout: list[list[BaseWidget]]):\n        \"\"\"Set the layout of the VStack\"\"\"\n        self._layout_lol = layout\n        self._layout_list = [widget for row in layout for widget in row]\n\n    @debug_watch\n    def _insert_widget_row_col(\n        self, widget: BaseWidget, row: int, col: int, is_vertical: bool = True\n    ):\n        \"\"\"Insert a widget into the container after the container has been created\n            Intended for use at run-time only when widgets need to be added dynamically\n\n        Args:\n            widget: (Widget) the widget to add\n            row: (int) the row to insert the widget into\n            col: (int) the column to insert the widget into\n\n        Note: widgets are placed in a grid with row, col coordinates by the _LayoutMixin class.\n        All containers store widgets internally as a list so we need to convert the row, col\n        coordinates to a list index.\n        \"\"\"\n        super()._insert_widget_row_col(widget, row, col, is_vertical=False)\n</code></pre>"},{"location":"reference/#guitk.HStack.layout","title":"<code>layout: list[list[BaseWidget]]</code>  <code>property</code> <code>writable</code>","text":"<p>Return the layout of the HStack</p>"},{"location":"reference/#guitk.HStack.__init__","title":"<code>__init__(key=None, height=None, padding=None, disabled=False, sticky='nsew', valign=None, halign=None, vexpand=True, hexpand=True, distribute=False, vspacing=None, hspacing=None, vscrollbar=False, autohide_scrollbars=True)</code>","text":"<p>A container that stacks widgets horizontally when added to a Layout</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>The key to use for the HStack. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the HStack. Defaults to None.</p> <code>None</code> <code>padding</code> <code>PaddingType</code> <p>The padding around the HStack. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the HStack is disabled. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str</code> <p>The sticky value for the HStack. Defaults to \"nsew\".</p> <code>'nsew'</code> <code>valign</code> <code>VAlign</code> <p>The vertical alignment for the widgets in the HStack. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign</code> <p>The horizontal alignment for the widgets in the HStack. Defaults to None.</p> <code>None</code> <code>vexpand</code> <code>bool</code> <p>Whether the Stack should expand vertically. Defaults to True.</p> <code>True</code> <code>hexpand</code> <code>bool</code> <p>Whether the Stack should expand horizontally. Defaults to True.</p> <code>True</code> <code>distribute</code> <code>bool</code> <p>Whether the HStack should distribute widgets evenly.</p> <code>False</code> <code>vspacing</code> <code>PadType</code> <p>Vertical spacing between widgets. Defaults to None.</p> <code>None</code> <code>hspacing</code> <code>PadType</code> <p>Horizontal spacing between widgets. Defaults to None.</p> <code>None</code> <code>vscrollbar</code> <code>bool</code> <p>Whether to include a vertical scrollbar. Defaults to False.</p> <code>False</code> <code>autohide_scrollbars</code> <code>bool</code> <p>Whether to hide scrollbars when not needed. Defaults to True.</p> <code>True</code> Note <p>If height is specified, the HStack will not expand to fill the available space and the expand parameter will be ignored.</p> Source code in <code>guitk/containers.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    height: int | None = None,\n    padding: PaddingType | None = None,\n    disabled: bool | None = False,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    vexpand: bool = True,\n    hexpand: bool = True,\n    distribute: bool = False,\n    vspacing: PadType | None = None,\n    hspacing: PadType | None = None,\n    vscrollbar: bool = False,\n    # hscrollbar: bool = False,\n    autohide_scrollbars: bool = True,\n):\n    \"\"\"A container that stacks widgets horizontally when added to a Layout\n\n    Args:\n        key (Hashable, optional): The key to use for the HStack. Defaults to None.\n        height (int, optional): The height of the HStack. Defaults to None.\n        padding (PaddingType, optional): The padding around the HStack. Defaults to None.\n        disabled (bool, optional): Whether the HStack is disabled. Defaults to False.\n        sticky (str, optional): The sticky value for the HStack. Defaults to \"nsew\".\n        valign (VAlign, optional): The vertical alignment for the widgets in the HStack.\n            Defaults to None.\n        halign (HAlign, optional): The horizontal alignment for the widgets in the HStack.\n            Defaults to None.\n        vexpand (bool, optional): Whether the Stack should expand vertically.\n            Defaults to True.\n        hexpand (bool, optional): Whether the Stack should expand horizontally.\n            Defaults to True.\n        distribute (bool, optional): Whether the HStack should distribute widgets evenly.\n        vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n        hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n        vscrollbar (bool): Whether to include a vertical scrollbar. Defaults to False.\n        autohide_scrollbars (bool): Whether to hide scrollbars when not needed. Defaults to True.\n\n    Note:\n        If height is specified, the HStack will not expand to fill the available space and the\n        expand parameter will be ignored.\n    \"\"\"\n    super().__init__(\n        key=key,\n        height=height,\n        width=None,\n        padding=padding,\n        disabled=disabled,\n        sticky=sticky,\n        valign=valign,\n        halign=halign,\n        vexpand=vexpand,\n        hexpand=hexpand,\n        distribute=distribute,\n        vspacing=vspacing,\n        hspacing=hspacing,\n        vscrollbar=vscrollbar,\n        # hscrollbar=hscrollbar,\n        autohide_scrollbars=autohide_scrollbars,\n    )\n</code></pre>"},{"location":"reference/#vstack","title":"VStack","text":"<p>               Bases: <code>_Stack</code></p> <p>A container that stacks widgets vertically when added to a Layout</p> Source code in <code>guitk/containers.py</code> <pre><code>class VStack(_Stack):\n    \"\"\"A container that stacks widgets vertically when added to a Layout\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        width: int | None = None,\n        # height: int | None = None,\n        padding: PaddingType | None = None,\n        disabled: bool | None = False,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        vexpand: bool = True,\n        hexpand: bool = True,\n        distribute: bool = False,\n        vspacing: PadType | None = None,\n        hspacing: PadType | None = None,\n        vscrollbar: bool = False,\n        # hscrollbar: bool = False,\n        autohide_scrollbars: bool = True,\n    ):\n        \"\"\"Base container container that stacks widgets vertically when added to a Layout\n\n        Args:\n            key (Hashable, optional): The key to use for the VStack. Defaults to None.\n            width (int, optional): The width of the VStack. Defaults to None.\n            padding (PaddingType, optional): The padding around the VStack. Defaults to None.\n            disabled (bool, optional): Whether the VStack is disabled. Defaults to False.\n            sticky (str, optional): The sticky value for the VStack. Defaults to \"nsew\".\n            valign (VAlign, optional): The vertical alignment for the widgets in the VStack.\n                Defaults to None.\n            halign (HAlign, optional): The horizontal alignment for the widgets in the VStack.\n                Defaults to None.\n            vexpand (bool, optional): Whether the Stack should expand vertically.\n                Defaults to True.\n            hexpand (bool, optional): Whether the Stack should expand horizontally.\n                Defaults to True.\n            distribute (bool, optional): Whether the VStack should distribute widgets evenly.\n            vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n            hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n            vscrollbar (bool): Whether to include a vertical scrollbar. Defaults to False.\n            autohide_scrollbars (bool): Whether to hide scrollbars when not needed. Defaults to True.\n\n        Note:\n            If width is specified, the VStack will not expand to fill the available space and the\n            expand parameter will be ignored.\n        \"\"\"\n        super().__init__(\n            key=key,\n            width=width,\n            height=None,\n            padding=padding,\n            disabled=disabled,\n            sticky=sticky,\n            valign=valign,\n            halign=halign,\n            vexpand=vexpand,\n            hexpand=hexpand,\n            distribute=distribute,\n            vspacing=vspacing,\n            hspacing=hspacing,\n            vscrollbar=vscrollbar,\n            # hscrollbar=hscrollbar,\n            autohide_scrollbars=autohide_scrollbars,\n        )\n</code></pre>"},{"location":"reference/#guitk.VStack.__init__","title":"<code>__init__(key=None, width=None, padding=None, disabled=False, sticky='nsew', valign=None, halign=None, vexpand=True, hexpand=True, distribute=False, vspacing=None, hspacing=None, vscrollbar=False, autohide_scrollbars=True)</code>","text":"<p>Base container container that stacks widgets vertically when added to a Layout</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>The key to use for the VStack. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the VStack. Defaults to None.</p> <code>None</code> <code>padding</code> <code>PaddingType</code> <p>The padding around the VStack. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the VStack is disabled. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str</code> <p>The sticky value for the VStack. Defaults to \"nsew\".</p> <code>'nsew'</code> <code>valign</code> <code>VAlign</code> <p>The vertical alignment for the widgets in the VStack. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign</code> <p>The horizontal alignment for the widgets in the VStack. Defaults to None.</p> <code>None</code> <code>vexpand</code> <code>bool</code> <p>Whether the Stack should expand vertically. Defaults to True.</p> <code>True</code> <code>hexpand</code> <code>bool</code> <p>Whether the Stack should expand horizontally. Defaults to True.</p> <code>True</code> <code>distribute</code> <code>bool</code> <p>Whether the VStack should distribute widgets evenly.</p> <code>False</code> <code>vspacing</code> <code>PadType</code> <p>Vertical spacing between widgets. Defaults to None.</p> <code>None</code> <code>hspacing</code> <code>PadType</code> <p>Horizontal spacing between widgets. Defaults to None.</p> <code>None</code> <code>vscrollbar</code> <code>bool</code> <p>Whether to include a vertical scrollbar. Defaults to False.</p> <code>False</code> <code>autohide_scrollbars</code> <code>bool</code> <p>Whether to hide scrollbars when not needed. Defaults to True.</p> <code>True</code> Note <p>If width is specified, the VStack will not expand to fill the available space and the expand parameter will be ignored.</p> Source code in <code>guitk/containers.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    width: int | None = None,\n    # height: int | None = None,\n    padding: PaddingType | None = None,\n    disabled: bool | None = False,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    vexpand: bool = True,\n    hexpand: bool = True,\n    distribute: bool = False,\n    vspacing: PadType | None = None,\n    hspacing: PadType | None = None,\n    vscrollbar: bool = False,\n    # hscrollbar: bool = False,\n    autohide_scrollbars: bool = True,\n):\n    \"\"\"Base container container that stacks widgets vertically when added to a Layout\n\n    Args:\n        key (Hashable, optional): The key to use for the VStack. Defaults to None.\n        width (int, optional): The width of the VStack. Defaults to None.\n        padding (PaddingType, optional): The padding around the VStack. Defaults to None.\n        disabled (bool, optional): Whether the VStack is disabled. Defaults to False.\n        sticky (str, optional): The sticky value for the VStack. Defaults to \"nsew\".\n        valign (VAlign, optional): The vertical alignment for the widgets in the VStack.\n            Defaults to None.\n        halign (HAlign, optional): The horizontal alignment for the widgets in the VStack.\n            Defaults to None.\n        vexpand (bool, optional): Whether the Stack should expand vertically.\n            Defaults to True.\n        hexpand (bool, optional): Whether the Stack should expand horizontally.\n            Defaults to True.\n        distribute (bool, optional): Whether the VStack should distribute widgets evenly.\n        vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n        hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n        vscrollbar (bool): Whether to include a vertical scrollbar. Defaults to False.\n        autohide_scrollbars (bool): Whether to hide scrollbars when not needed. Defaults to True.\n\n    Note:\n        If width is specified, the VStack will not expand to fill the available space and the\n        expand parameter will be ignored.\n    \"\"\"\n    super().__init__(\n        key=key,\n        width=width,\n        height=None,\n        padding=padding,\n        disabled=disabled,\n        sticky=sticky,\n        valign=valign,\n        halign=halign,\n        vexpand=vexpand,\n        hexpand=hexpand,\n        distribute=distribute,\n        vspacing=vspacing,\n        hspacing=hspacing,\n        vscrollbar=vscrollbar,\n        # hscrollbar=hscrollbar,\n        autohide_scrollbars=autohide_scrollbars,\n    )\n</code></pre>"},{"location":"reference/#hspacer","title":"HSpacer","text":"<p>               Bases: <code>Label</code></p> <p>HSpacer widget that expands to fill the horizontal space in the layout</p> Source code in <code>guitk/spacer.py</code> <pre><code>class HSpacer(Label):\n    \"\"\"HSpacer widget that expands to fill the horizontal space in the layout\"\"\"\n\n    def __init__(self, rowspan=1):\n        super().__init__(\n            \"\",\n            padding=0,\n            disabled=True,\n            sticky=\"nsew\",\n            autoframe=False,\n            borderwidth=debug_borderwidth() or None,\n            relief=debug_relief() or None,\n            weightx=1,\n            rowspan=rowspan,\n        )\n\n    def _create_widget(self, parent: tk.BaseWidget, window: Window, row: int, col: int):\n        super()._create_widget(parent, window, row, col)\n</code></pre>"},{"location":"reference/#vspacer","title":"VSpacer","text":"<p>               Bases: <code>Label</code></p> <p>\"HSpacer widget that expands to fill the vertical space in the layout</p> Source code in <code>guitk/spacer.py</code> <pre><code>class VSpacer(Label):\n    \"\"\" \"HSpacer widget that expands to fill the vertical space in the layout\"\"\"\n\n    def __init__(self, columnspan=1):\n        super().__init__(\n            \"\",\n            padding=0,\n            disabled=True,\n            sticky=\"nsew\",\n            autoframe=False,\n            borderwidth=debug_borderwidth() or None,\n            relief=debug_relief() or None,\n            weighty=1,\n            columnspan=columnspan,\n        )\n\n    def _create_widget(self, parent: tk.BaseWidget, window: Window, row: int, col: int):\n        super()._create_widget(parent, window, row, col)\n</code></pre>"},{"location":"reference/#button","title":"Button","text":"<p>               Bases: <code>BaseWidget</code></p> <p>Basic button</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class Button(BaseWidget):\n    \"\"\"Basic button\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        image: str | None = None,\n        key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a Button widget.\n\n        Args:\n            text (str): Text for the button.\n            image (str | None, optional): Image for the button. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button.\n\n        Note:\n            Emits EventType.ButtonPress event.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n\n        self.widget_type = \"ttk.Button\"\n        self.text = text\n        self.image = image\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tooltip = tooltip\n        self.padx = padx\n        self.pady = pady\n        self.kwargs = kwargs\n\n    @property\n    def value(self) -&gt; str:\n        return self.widget[\"text\"]\n\n    @value.setter\n    def value(self, text: str):\n        self.widget[\"text\"] = text\n\n    def _create_widget(self, parent: Any, window: Window, row: int, col: int):\n        \"\"\"Create the ttk.Button widget\"\"\"\n        event = Event(self, window, self.key, EventType.ButtonPress)\n\n        # build arg list for Button()\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n\n        if self.image:\n            self._photoimage = load_image(self.image)\n            kwargs_button[\"image\"] = self._photoimage\n\n        self.widget = ttk.Button(\n            parent,\n            text=self.text,\n            command=window._make_callback(event),\n            **kwargs_button,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ButtonPress,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def button(self):\n        \"\"\"Return the Tk button widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Button.button","title":"<code>button</code>  <code>property</code>","text":"<p>Return the Tk button widget</p>"},{"location":"reference/#guitk.Button.__init__","title":"<code>__init__(text, image=None, key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> required <code>image</code> <code>str | None</code> <p>Image for the button. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button.</p> <code>{}</code> Note <p>Emits EventType.ButtonPress event.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    image: str | None = None,\n    key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a Button widget.\n\n    Args:\n        text (str): Text for the button.\n        image (str | None, optional): Image for the button. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button.\n\n    Note:\n        Emits EventType.ButtonPress event.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n\n    self.widget_type = \"ttk.Button\"\n    self.text = text\n    self.image = image\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.tooltip = tooltip\n    self.padx = padx\n    self.pady = pady\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#browsefilebutton","title":"BrowseFileButton","text":"<p>               Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a file.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseFileButton(Button):\n    \"\"\"Button that opens a file dialog to select a file.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        filename_only: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a BrowseFileButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected filename.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n\n        Note:\n            Emits a EventType.BrowseFile event after the file dialog is closed.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseFileButton\"\n        self._filename = None\n        self._filename_only = filename_only\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def filename(self):\n        return self._filename\n\n    def browse_dialog(self):\n        \"\"\"Open a file dialog to select a file\"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._filename = filedialog.askopenfilename(**kwargs_options)\n        if self._filename_only and self._filename:\n            # only want the name, not the path\n            self._filename = pathlib.Path(self._filename).name\n        if self.target_key and self._filename:\n            self.window[self.target_key].value = self._filename\n        event = Event(self, self.window, self.key, EventType.BrowseFile)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.BrowseFileButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, filename_only=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseFileButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected filename.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>filename_only</code> <code>bool</code> <p>If True, only the filename is returned. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Note <p>Emits a EventType.BrowseFile event after the file dialog is closed.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    filename_only: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a BrowseFileButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected filename.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n\n    Note:\n        Emits a EventType.BrowseFile event after the file dialog is closed.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseFileButton\"\n    self._filename = None\n    self._filename_only = filename_only\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.BrowseFileButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a file</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n    \"\"\"Open a file dialog to select a file\"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._filename = filedialog.askopenfilename(**kwargs_options)\n    if self._filename_only and self._filename:\n        # only want the name, not the path\n        self._filename = pathlib.Path(self._filename).name\n    if self.target_key and self._filename:\n        self.window[self.target_key].value = self._filename\n    event = Event(self, self.window, self.key, EventType.BrowseFile)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#browsedirectorybutton","title":"BrowseDirectoryButton","text":"<p>               Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseDirectoryButton(Button):\n    \"\"\"Button that opens a file dialog to select a directory.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a BrowseDirectoryButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected directory.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n\n        Note:\n            Emits a EventType.BrowseDirectory event after the file dialog is closed.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseDirectoryButton\"\n        self._dirname = None\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def directory(self):\n        return self._dirname\n\n    def browse_dialog(self):\n        \"\"\"\n        Open a file dialog to select a directory.\n        \"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._dirname = filedialog.askdirectory(**kwargs_options)\n        if self.target_key and self._dirname:\n            self.window[self.target_key].value = self._dirname\n        event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.BrowseDirectoryButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseDirectoryButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected directory.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Note <p>Emits a EventType.BrowseDirectory event after the file dialog is closed.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a BrowseDirectoryButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected directory.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n\n    Note:\n        Emits a EventType.BrowseDirectory event after the file dialog is closed.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseDirectoryButton\"\n    self._dirname = None\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.BrowseDirectoryButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n    \"\"\"\n    Open a file dialog to select a directory.\n    \"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._dirname = filedialog.askdirectory(**kwargs_options)\n    if self.target_key and self._dirname:\n        self.window[self.target_key].value = self._dirname\n    event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#checkbutton","title":"Checkbutton","text":"<p>               Bases: <code>BaseWidget</code></p> <p>Checkbox / checkbutton</p> Source code in <code>guitk/ttk_checkbutton.py</code> <pre><code>class Checkbutton(BaseWidget):\n    \"\"\"Checkbox / checkbutton\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        checked: bool = False,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a ttk.Checkbutton widget.\n\n        Args:\n            text (str): Text for the checkbutton.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            checked (bool, optional): Initial state. Defaults to False (not checked).\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n            weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n\n        Notes:\n            Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False.\n            Emits an EventType.Checkbutton event when the checkbutton is clicked.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Checkbutton\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self._value: tk.BooleanVar = tk.BooleanVar()\n        self._checked = checked\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        event = Event(self, window, self.key, EventType.Checkbutton)\n\n        # build arg list for Checkbutton\n        kwargs_checkbutton = {\n            k: v\n            for k, v in self.kwargs.items()\n            if k in _valid_ttk_checkbutton_attributes\n        }\n\n        self.widget = ttk.Checkbutton(\n            parent,\n            text=self.text,\n            anchor=self.kwargs.get(\"anchor\"),\n            command=window._make_callback(event),\n            variable=self._value,\n            onvalue=True,\n            **kwargs_checkbutton,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.Checkbutton,\n                    command=self._command,\n                )\n            )\n\n        if self._checked:\n            self.widget.invoke()\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n        return self.widget\n\n    @property\n    def checkbutton(self):\n        \"\"\"Return the ttk.Checkbutton widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Checkbutton.checkbutton","title":"<code>checkbutton</code>  <code>property</code>","text":"<p>Return the ttk.Checkbutton widget</p>"},{"location":"reference/#guitk.Checkbutton.__init__","title":"<code>__init__(text, key=None, checked=False, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a ttk.Checkbutton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the checkbutton.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>checked</code> <code>bool</code> <p>Initial state. Defaults to False (not checked).</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight of widget in X direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of widget in Y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Checkbutton.</p> <code>{}</code> Notes <p>Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False. Emits an EventType.Checkbutton event when the checkbutton is clicked.</p> Source code in <code>guitk/ttk_checkbutton.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    checked: bool = False,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a ttk.Checkbutton widget.\n\n    Args:\n        text (str): Text for the checkbutton.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        checked (bool, optional): Initial state. Defaults to False (not checked).\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n        weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n\n    Notes:\n        Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False.\n        Emits an EventType.Checkbutton event when the checkbutton is clicked.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Checkbutton\"\n    self.text = text\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self._value: tk.BooleanVar = tk.BooleanVar()\n    self._checked = checked\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#combobox","title":"Combobox","text":"<p>               Bases: <code>BaseWidget</code></p> <p>ttk Combobox</p> Source code in <code>guitk/ttk_combobox.py</code> <pre><code>class Combobox(BaseWidget):\n    \"\"\"ttk Combobox\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        default: str | None = None,\n        values: list[str] | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        keyrelease: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        readonly: bool = False,\n        autosize: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        \"\"\"\n        Initialize a ttk.Combobox widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str, optional): Default value. Defaults to None.\n            values (list[str], optional): List of values for the combobox. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            keyrelease (bool, optional): If True and events is True, emit EventType.KeyRelease event when a key is released.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            readonly (bool, optional): If True, widget is read-only. Defaults to False.\n                If Combobox is not readonly, user can type in a value that is not in the list of values.\n            autosize (bool, optional): If True, automatically set width to fit longest value. Defaults to False.\n            weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n            weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n\n        Note:\n            Emits EventType.ComboboxSelected event when a value is selected from the list.\n            Emits EventType.ComboboxReturn event when the Return key is pressed.\n            Emits EventType.KeyRelease event when a key is released (if keyrelease is True).\n        \"\"\"\n        self.widget_type = \"ttk.Combobox\"\n        self.key = key or \"Combobox\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self._readonly = readonly\n        self._autosize = autosize\n        self.kwargs = kwargs\n        self.values = values\n        self.default = default\n        self.keyrelease = keyrelease\n\n    def _create_widget(self, parent, window: Window, row, col):\n        # build arg list for Combobox\n        kwargs = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_combobox_attributes\n        }\n\n        if self._autosize:\n            # automatically set width, override any width value provided\n            width = len(max(self.values, key=len))\n            kwargs[\"width\"] = width + 1\n\n        self.widget = ttk.Combobox(\n            parent,\n            textvariable=self._value,\n            values=self.values,\n            **kwargs,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind events\n        if self.keyrelease:\n            event_release = Event(self, window, self.key, EventType.KeyRelease)\n            self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event_release))\n\n        event_selected = Event(self, window, self.key, EventType.ComboboxSelected)\n        self.widget.bind(\"&lt;&lt;ComboboxSelected&gt;&gt;\", window._make_callback(event_selected))\n\n        combo_return_key = Event(self, window, self.key, EventType.ComboboxReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(combo_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ComboboxSelected,\n                    command=self._command,\n                )\n            )\n\n        if self.default is not None:\n            self.value = self.default\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        if self._readonly:\n            self.widget.state([\"readonly\"])\n\n        return self.widget\n\n    @property\n    def combobox(self):\n        \"\"\"Return the Tk combobox widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Combobox.combobox","title":"<code>combobox</code>  <code>property</code>","text":"<p>Return the Tk combobox widget</p>"},{"location":"reference/#entry","title":"Entry","text":"<p>               Bases: <code>BaseWidget</code></p> <p>ttk.Entry text entry / input box</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class Entry(BaseWidget):\n    \"\"\"ttk.Entry text entry / input box\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        keyrelease: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize an Entry widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to True.\n            keyrelease (bool, optional): If True, generate events on key release. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n        Note:\n            Emits EventType.EntryReturn event on return key press.\n            If keyrelease is True, emits EventType.KeyRelease event on every key release.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Entry\"\n        default = default or \"\"\n        self._value.set(default)\n        self.key = key or \"Entry\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.hscrollbar = hscrollbar\n        self.keyrelease = keyrelease\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        # build arg list for ttk.Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            ttk.Entry,\n            hscrollbar=self.hscrollbar,\n            textvariable=self._value,\n            **kwargs_entry,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        if self.keyrelease:\n            event = Event(self, window, self.key, EventType.KeyRelease)\n            self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n        \"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Entry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.Entry.__init__","title":"<code>__init__(key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, keyrelease=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to True.</p> <code>True</code> <code>keyrelease</code> <code>bool</code> <p>If True, generate events on key release. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Note <p>Emits EventType.EntryReturn event on return key press. If keyrelease is True, emits EventType.KeyRelease event on every key release.</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    keyrelease: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize an Entry widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to True.\n        keyrelease (bool, optional): If True, generate events on key release. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n    Note:\n        Emits EventType.EntryReturn event on return key press.\n        If keyrelease is True, emits EventType.KeyRelease event on every key release.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Entry\"\n    default = default or \"\"\n    self._value.set(default)\n    self.key = key or \"Entry\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.hscrollbar = hscrollbar\n    self.keyrelease = keyrelease\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#labelentry","title":"LabelEntry","text":"<p>               Bases: <code>Entry</code></p> <p>Text entry / input box with a label</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class LabelEntry(Entry):\n    \"\"\"Text entry / input box with a label\"\"\"\n\n    # TODO: add option to put label above the entry box\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        keyrelease: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize an Entry widget.\n\n        Args:\n            text (str): Label text.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to True.\n            keyrelease (bool, optional): If True, emits EventType.KeyRelease event on every key release.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n        Note:\n            Emits EventType.EntryReturn event on return key press.\n            If keyrelease is True, emits EventType.KeyRelease event on every key release.\n        \"\"\"\n        super().__init__(\n            key=key,\n            default=default,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            keyrelease=keyrelease,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            hscrollbar=hscrollbar,\n            focus=focus,\n            weightx=weightx,\n            weighty=weighty,\n        )\n        self.widget_type = \"guitk.LabelEntry\"\n        self.text = text\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        # build arg list for Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = _ttkLabelEntry(\n            parent, text=self.text, textvariable=self._value, **kwargs_entry\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n        \"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.LabelEntry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.LabelEntry.__init__","title":"<code>__init__(text, key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, keyrelease=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Label text.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to True.</p> <code>True</code> <code>keyrelease</code> <code>bool</code> <p>If True, emits EventType.KeyRelease event on every key release.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget will have focus. Defaults to False. Only one widget can have focus.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Note <p>Emits EventType.EntryReturn event on return key press. If keyrelease is True, emits EventType.KeyRelease event on every key release.</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    keyrelease: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize an Entry widget.\n\n    Args:\n        text (str): Label text.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to True.\n        keyrelease (bool, optional): If True, emits EventType.KeyRelease event on every key release.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n    Note:\n        Emits EventType.EntryReturn event on return key press.\n        If keyrelease is True, emits EventType.KeyRelease event on every key release.\n    \"\"\"\n    super().__init__(\n        key=key,\n        default=default,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        keyrelease=keyrelease,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        hscrollbar=hscrollbar,\n        focus=focus,\n        weightx=weightx,\n        weighty=weighty,\n    )\n    self.widget_type = \"guitk.LabelEntry\"\n    self.text = text\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#label","title":"Label","text":"<p>               Bases: <code>BaseWidget</code></p> <p>ttk.Label widget</p> Source code in <code>guitk/ttk_label.py</code> <pre><code>class Label(BaseWidget):\n    \"\"\"ttk.Label widget\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        image: str | None = None,\n        key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a Label widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            text (str): Text to display in the label.\n            image: (str, optional): Path to image to display in the label. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            weightx (int | None, optional): Weight of this widget in the horizontal direction. Defaults to None.\n            weighty (int | None, optional): Weight of this widget in the vertical direction. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n        )\n        self.widget_type = \"ttk.Label\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.image = image\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        \"\"\"Create the ttk.Label widget\"\"\"\n\n        # Arg list for ttk.Label\n        kwargs_label = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_label_attributes\n        }\n\n        if self.image:\n            self._photoimage = load_image(self.image)\n            kwargs_label[\"image\"] = self._photoimage\n\n        self.widget = ttk.Label(\n            parent,\n            text=self.text,\n            **kwargs_label,\n        )\n        self.widget[\"textvariable\"] = self._value\n        self._value.set(self.text)\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n        return self.widget\n\n    @property\n    def label(self):\n        \"\"\"Return the Tk label widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Label.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the Tk label widget</p>"},{"location":"reference/#guitk.Label.__init__","title":"<code>__init__(text, image=None, key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, weightx=None, weighty=None, **kwargs)</code>","text":"<p>Initialize a Label widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>text</code> <code>str</code> <p>Text to display in the label.</p> required <code>image</code> <code>str | None</code> <p>(str, optional): Path to image to display in the label. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight of this widget in the horizontal direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of this widget in the vertical direction. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_label.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    image: str | None = None,\n    key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a Label widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        text (str): Text to display in the label.\n        image: (str, optional): Path to image to display in the label. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        weightx (int | None, optional): Weight of this widget in the horizontal direction. Defaults to None.\n        weighty (int | None, optional): Weight of this widget in the vertical direction. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n    )\n    self.widget_type = \"ttk.Label\"\n    self.text = text\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.image = image\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#notebook","title":"Notebook","text":"<p>               Bases: <code>_Container</code></p> <p>ttk.Notebook widget</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class Notebook(_Container):\n    \"\"\"ttk.Notebook widget\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        tabs: list[HTab] | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Notebook widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            tabs: (list[Tab], optional): Tabs to add to the notebook. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command to execute when clicked. Defaults to None.\n            weightx (int | None, optional): Horizontal weight. Defaults to None.\n            weighty (int | None, optional): Vertical weight. Defaults to None.\n            focus (bool, optional): If True, widget will have focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n\n        Note:\n            Emits EventType.NotebookTabChanged event.\n        \"\"\"\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=disabled,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=False,\n            padx=0,\n            pady=0,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Notebook\"\n        self.key = key or \"Notebook\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tabs = tabs or []\n        self._command = command\n        self.kwargs = kwargs\n        self._tab_count = 0\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        # Arg list for ttk.Label\n        kwargs_notebook = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_notebook_attributes\n        }\n\n        self.widget = ttk.Notebook(parent, **kwargs_notebook)\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event_tab_change = Event(self, window, self.key, EventType.NotebookTabChanged)\n        self.widget.bind(\n            \"&lt;&lt;NotebookTabChanged&gt;&gt;\", window._make_callback(event_tab_change)\n        )\n\n        if self.layout:\n            for row in self.layout:\n                for tab in row:\n                    self.add(tab)\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                # the actual widget will be a tk widget in form widget=.!toplevel.!frame.!notebook, so it won't match self.widget\n                # so set widget=None or _handle_commands won't correctly handle the command\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.NotebookTabChanged,\n                    command=self._command,\n                )\n            )\n\n        if self.width or self.height:\n            self.widget.grid_propagate(0)\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def current_tab(self):\n        \"\"\"Return the name of the currently selected tab\"\"\"\n        return self.notebook.tab(self.notebook.select(), \"text\")\n\n    def add(self, tab: HTab):\n        \"\"\"Add a Tab to the Notebook as new tab\"\"\"\n        tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n        tab.kwargs[\"text\"] = tab.name\n        self.notebook.add(tab_, **tab.kwargs)\n\n    def insert(self, pos, tab: HTab):\n        \"\"\"Insert a layout to the Notebook as new tab at position pos\"\"\"\n        tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n        tab.kwargs[\"text\"] = tab.name\n        self.notebook.insert(pos, tab_, **tab.kwargs)\n\n    @property\n    def notebook(self):\n        \"\"\"Return the ttk.Notebook widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Notebook.current_tab","title":"<code>current_tab</code>  <code>property</code>","text":"<p>Return the name of the currently selected tab</p>"},{"location":"reference/#guitk.Notebook.notebook","title":"<code>notebook</code>  <code>property</code>","text":"<p>Return the ttk.Notebook widget</p>"},{"location":"reference/#guitk.Notebook.__init__","title":"<code>__init__(key=None, tabs=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Notebook widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>tabs</code> <code>list[HTab] | None</code> <p>(list[Tab], optional): Tabs to add to the notebook. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command to execute when clicked. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Horizontal weight. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Vertical weight. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget will have focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Note <p>Emits EventType.NotebookTabChanged event.</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    tabs: list[HTab] | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a Notebook widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        tabs: (list[Tab], optional): Tabs to add to the notebook. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command to execute when clicked. Defaults to None.\n        weightx (int | None, optional): Horizontal weight. Defaults to None.\n        weighty (int | None, optional): Vertical weight. Defaults to None.\n        focus (bool, optional): If True, widget will have focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n\n\n    Note:\n        Emits EventType.NotebookTabChanged event.\n    \"\"\"\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=disabled,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=False,\n        padx=0,\n        pady=0,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Notebook\"\n    self.key = key or \"Notebook\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.tabs = tabs or []\n    self._command = command\n    self.kwargs = kwargs\n    self._tab_count = 0\n</code></pre>"},{"location":"reference/#guitk.Notebook.add","title":"<code>add(tab)</code>","text":"<p>Add a Tab to the Notebook as new tab</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def add(self, tab: HTab):\n    \"\"\"Add a Tab to the Notebook as new tab\"\"\"\n    tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n    tab.kwargs[\"text\"] = tab.name\n    self.notebook.add(tab_, **tab.kwargs)\n</code></pre>"},{"location":"reference/#guitk.Notebook.insert","title":"<code>insert(pos, tab)</code>","text":"<p>Insert a layout to the Notebook as new tab at position pos</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def insert(self, pos, tab: HTab):\n    \"\"\"Insert a layout to the Notebook as new tab at position pos\"\"\"\n    tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n    tab.kwargs[\"text\"] = tab.name\n    self.notebook.insert(pos, tab_, **tab.kwargs)\n</code></pre>"},{"location":"reference/#htab","title":"HTab","text":"<p>               Bases: <code>_Container</code></p> <p>Tab for Notebook widget that arranges its widgets horizontally</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class HTab(_Container):\n    \"\"\"Tab for Notebook widget that arranges its widgets horizontally\"\"\"\n\n    def __init__(\n        self,\n        name=None,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a horizontal Tab\n\n        Args:\n            name (str, optional): Name of the tab. Defaults to None.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n            halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Frame.\n        \"\"\"\n\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=False,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=True,\n            valign=valign,\n            halign=halign,\n            padx=0,\n            pady=0,\n        )\n        self.name = name\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.HTab.__init__","title":"<code>__init__(name=None, sticky='nsew', valign=None, halign=None, **kwargs)</code>","text":"<p>Initialize a horizontal Tab</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tab. Defaults to None.</p> <code>None</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>'nsew'</code> <code>valign</code> <code>VAlign | None</code> <p>Vertical alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign | None</code> <p>Horizontal alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Frame.</p> <code>{}</code> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    **kwargs,\n):\n    \"\"\"Initialize a horizontal Tab\n\n    Args:\n        name (str, optional): Name of the tab. Defaults to None.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n        halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Frame.\n    \"\"\"\n\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=False,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=True,\n        valign=valign,\n        halign=halign,\n        padx=0,\n        pady=0,\n    )\n    self.name = name\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#vtab","title":"VTab","text":"<p>               Bases: <code>HTab</code>, <code>_VerticalContainer</code></p> <p>Tab for Notebook widget that arranges its widgets vertically</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class VTab(HTab, _VerticalContainer):\n    \"\"\"Tab for Notebook widget that arranges its widgets vertically\"\"\"\n\n    def __init__(\n        self,\n        name=None,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a vertical Tab\n\n        Args:\n            name (str, optional): Name of the tab. Defaults to None.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n            halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Frame.\n        \"\"\"\n\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=False,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=True,\n            padx=0,\n            pady=0,\n            valign=valign,\n            halign=halign,\n        )\n        self.name = name\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.VTab.__init__","title":"<code>__init__(name=None, sticky='nsew', valign=None, halign=None, **kwargs)</code>","text":"<p>Initialize a vertical Tab</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tab. Defaults to None.</p> <code>None</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>'nsew'</code> <code>valign</code> <code>VAlign | None</code> <p>Vertical alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign | None</code> <p>Horizontal alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Frame.</p> <code>{}</code> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    **kwargs,\n):\n    \"\"\"Initialize a vertical Tab\n\n    Args:\n        name (str, optional): Name of the tab. Defaults to None.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n        halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Frame.\n    \"\"\"\n\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=False,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=True,\n        padx=0,\n        pady=0,\n        valign=valign,\n        halign=halign,\n    )\n    self.name = name\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#text","title":"Text","text":"<p>               Bases: <code>BaseWidget</code></p> <p>A tk Text box</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Text(BaseWidget):\n    \"\"\"A tk Text box\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        vscrollbar: bool = False,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a Text widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n\n        Note:\n            Emits EventType.KeyRelease events when the text is changed and events is True.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"tk.Text\"\n        self.key = key or \"Text\"\n        self.width = width\n        self.height = height\n        self._value = text if text is not None else \"\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.vscrollbar = vscrollbar\n        self.hscrollbar = hscrollbar\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_text = {\n            k: v for k, v in self.kwargs.items() if k in _valid_tk_text_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            tk.Text,\n            vscrollbar=self.vscrollbar,\n            hscrollbar=self.hscrollbar,\n            width=self.width,\n            height=self.height,\n            **kwargs_text,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        self.value = self._value\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget[\"state\"] = \"disabled\"\n\n        return self.widget\n\n    @property\n    def value(self):\n        return self.widget.get(\"1.0\", tk.END).rstrip()\n\n    @value.setter\n    def value(self, text):\n        self.widget.delete(\"1.0\", tk.END)\n        self.widget.insert(\"1.0\", text)\n\n    @property\n    def text(self):\n        \"\"\"Return the Tk text widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.Text.text","title":"<code>text</code>  <code>property</code>","text":"<p>Return the Tk text widget</p>"},{"location":"reference/#guitk.Text.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, vscrollbar=False, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Text widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>False</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Note <p>Emits EventType.KeyRelease events when the text is changed and events is True.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    vscrollbar: bool = False,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a Text widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n\n    Note:\n        Emits EventType.KeyRelease events when the text is changed and events is True.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"tk.Text\"\n    self.key = key or \"Text\"\n    self.width = width\n    self.height = height\n    self._value = text if text is not None else \"\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.vscrollbar = vscrollbar\n    self.hscrollbar = hscrollbar\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#output","title":"Output","text":"<p>               Bases: <code>Text</code></p> <p>Text box that redirects stderr and/or stdout to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Output(Text):\n    \"\"\"Text box that redirects stderr and/or stdout to the text box.\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        vscrollbar: bool = True,\n        hscrollbar: bool = False,\n        stdout: bool = True,\n        stderr: bool = True,\n        echo: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize an Output widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n            stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n            echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n        \"\"\"\n        super().__init__(\n            text=text,\n            key=key,\n            width=width,\n            height=height,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            vscrollbar=vscrollbar,\n            hscrollbar=hscrollbar,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n            **kwargs,\n        )\n\n        self.kwargs = kwargs\n        self._echo = echo\n        self._stdout = stdout\n        self._stderr = stderr\n\n        # stores state for stdout and stderr redirection\n        self._redirect = []\n        self._redirect_id = {}\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        self.widget = super()._create_widget(parent, window, row, col)\n\n        # Unbind &lt;KeyRelease&gt; since this isn't for user input\n        self.widget.unbind(\"&lt;KeyRelease&gt;\")\n\n        if self.events:\n            event = Event(self, window, self.key, EventType.OutputWrite)\n            self.window.root.bind_all(\n                EventType.OutputWrite.value, window._make_callback(event)\n            )\n\n        self._configure_redirect()\n        self.enable_redirect()\n\n        return self.widget\n\n    def _configure_redirect(self):\n        \"\"\"Configure stdout and stderr redirection.\"\"\"\n        if self._stdout:\n            self._redirect.append(StdOutRedirect())\n        if self._stderr:\n            self._redirect.append(StdErrRedirect())\n        for r in self._redirect:\n            r.echo = self._echo\n            self._redirect_id[r] = r.register(self._write)\n\n    def _write(self, line):\n        with contextlib.suppress(tk.TclError):\n            # ignore TclError if widget has been destroyed while trying to write\n            self.text.insert(tk.END, line)\n            self.text.yview(tk.END)\n        self.window.root.event_generate(EventType.OutputWrite.value)\n\n    @property\n    def echo(self):\n        \"\"\"Return True if stdout and stderr are echoed to the console.\"\"\"\n        return self._echo\n\n    @echo.setter\n    def echo(self, echo):\n        \"\"\"Set whether stdout and stderr are echoed to the console.\"\"\"\n        self._echo = echo\n        for r in self._redirect:\n            r.echo = echo\n\n    def disable_redirect(self):\n        \"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.disable_redirect()\n\n    def enable_redirect(self):\n        \"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.enable_redirect()\n\n    def __del__(self):\n        for r, id_ in self._redirect_id.items():\n            r.deregister(id_)\n</code></pre>"},{"location":"reference/#guitk.Output.echo","title":"<code>echo</code>  <code>property</code> <code>writable</code>","text":"<p>Return True if stdout and stderr are echoed to the console.</p>"},{"location":"reference/#guitk.Output.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, vscrollbar=True, hscrollbar=False, stdout=True, stderr=True, echo=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Output widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> required <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>True</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>stdout</code> <code>bool</code> <p>Redirect stdout to the text box. Defaults to True.</p> <code>True</code> <code>stderr</code> <code>bool</code> <p>Redirect stderr to the text box. Defaults to True.</p> <code>True</code> <code>echo</code> <code>bool</code> <p>Echo stdout and stderr to the console. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    vscrollbar: bool = True,\n    hscrollbar: bool = False,\n    stdout: bool = True,\n    stderr: bool = True,\n    echo: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Initialize an Output widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n        stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n        echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n    \"\"\"\n    super().__init__(\n        text=text,\n        key=key,\n        width=width,\n        height=height,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        vscrollbar=vscrollbar,\n        hscrollbar=hscrollbar,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n        **kwargs,\n    )\n\n    self.kwargs = kwargs\n    self._echo = echo\n    self._stdout = stdout\n    self._stderr = stderr\n\n    # stores state for stdout and stderr redirection\n    self._redirect = []\n    self._redirect_id = {}\n</code></pre>"},{"location":"reference/#guitk.Output.disable_redirect","title":"<code>disable_redirect()</code>","text":"<p>Disable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def disable_redirect(self):\n    \"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.disable_redirect()\n</code></pre>"},{"location":"reference/#guitk.Output.enable_redirect","title":"<code>enable_redirect()</code>","text":"<p>Enable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def enable_redirect(self):\n    \"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.enable_redirect()\n</code></pre>"},{"location":"reference/#menubar","title":"MenuBar","text":"<p>Menu bar manager that can be used to create a menu bar for a Window</p> Source code in <code>guitk/menu.py</code> <pre><code>class MenuBar:\n    \"\"\"Menu bar manager that can be used to create a menu bar for a Window\"\"\"\n\n    def __init__(\n        self,\n    ):\n        \"\"\"Create a new MenuBar.\n\n        Examples:\n            ```python\n            import guitk as ui\n\n            class MenuDemo(ui.Window):\n                def config(self):\n                    with ui.VLayout():\n                        ui.Label(\"This window has menus!\")\n\n                    with ui.MenuBar():\n                        with ui.Menu(\"File\"):\n                            ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                            with ui.SubMenu(\"Open Recent\"):\n                                ui.Command(\"File 1\")\n                                ui.Command(\"File 2\")\n                                ui.Command(\"File 3\")\n                            ui.MenuSeparator()\n                            ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                            ui.Command(\"Save As\")\n                        with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                            ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                            ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                            ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n            ```\n        \"\"\"\n        self._index = 0\n        self.window = None\n        self._menu_list = []\n\n        # get the caller's instance so we can set the layout\n        caller_frame = currentframe().f_back\n        with contextlib.suppress(IndexError, KeyError):\n            first_arg = caller_frame.f_code.co_varnames[0]\n            caller_instance = caller_frame.f_locals[first_arg]\n            # determine if the caller is a Window\n            # need to use repr() because we can't import Window here without causing a circular import\n            if \"guitk.window.Window\" in repr(getmro(caller_instance.__class__)):\n                self.window = caller_instance\n                self.window.menu = self\n\n    def _add_widget(self, widget: _BaseMenu):\n        \"\"\"Add a menu item to the end of the Menu\"\"\"\n        self._menu_list.append(widget)\n\n    def __enter__(self):\n        push_parent(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pop_parent()\n        return False\n\n    def __iter__(self):\n        self._index = 0\n        return iter(self._menu_list)\n\n    def __next__(self) -&gt; Menu:\n        if self._index &gt;= len(self._menu_list):\n            raise StopIteration\n        value = self._menu_list[self._index]\n        self._index += 1\n        return value\n</code></pre>"},{"location":"reference/#guitk.MenuBar.__init__","title":"<code>__init__()</code>","text":"<p>Create a new MenuBar.</p> <p>Examples:</p> <pre><code>import guitk as ui\n\nclass MenuDemo(ui.Window):\n    def config(self):\n        with ui.VLayout():\n            ui.Label(\"This window has menus!\")\n\n        with ui.MenuBar():\n            with ui.Menu(\"File\"):\n                ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                with ui.SubMenu(\"Open Recent\"):\n                    ui.Command(\"File 1\")\n                    ui.Command(\"File 2\")\n                    ui.Command(\"File 3\")\n                ui.MenuSeparator()\n                ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                ui.Command(\"Save As\")\n            with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n</code></pre> Source code in <code>guitk/menu.py</code> <pre><code>def __init__(\n    self,\n):\n    \"\"\"Create a new MenuBar.\n\n    Examples:\n        ```python\n        import guitk as ui\n\n        class MenuDemo(ui.Window):\n            def config(self):\n                with ui.VLayout():\n                    ui.Label(\"This window has menus!\")\n\n                with ui.MenuBar():\n                    with ui.Menu(\"File\"):\n                        ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                        with ui.SubMenu(\"Open Recent\"):\n                            ui.Command(\"File 1\")\n                            ui.Command(\"File 2\")\n                            ui.Command(\"File 3\")\n                        ui.MenuSeparator()\n                        ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                        ui.Command(\"Save As\")\n                    with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                        ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                        ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                        ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n        ```\n    \"\"\"\n    self._index = 0\n    self.window = None\n    self._menu_list = []\n\n    # get the caller's instance so we can set the layout\n    caller_frame = currentframe().f_back\n    with contextlib.suppress(IndexError, KeyError):\n        first_arg = caller_frame.f_code.co_varnames[0]\n        caller_instance = caller_frame.f_locals[first_arg]\n        # determine if the caller is a Window\n        # need to use repr() because we can't import Window here without causing a circular import\n        if \"guitk.window.Window\" in repr(getmro(caller_instance.__class__)):\n            self.window = caller_instance\n            self.window.menu = self\n</code></pre>"},{"location":"reference/#menu","title":"Menu","text":"<p>               Bases: <code>_BaseMenu</code></p> Source code in <code>guitk/menu.py</code> <pre><code>class Menu(_BaseMenu):\n    def __init__(\n        self,\n        label: str,\n        underline: int | None = None,\n        key: Hashable | None = None,\n        disabled: bool = False,\n    ) -&gt; None:\n        \"\"\"Create a new Menu.\n\n        Args:\n            label (str): The label for the menu\n            underline (int, optional): The index of the character to underline in the label. Defaults to None.\n            key (Hashable, optional): The key to use to access the menu from parent Window.\n                Defaults to  f\"Menu:{label}\" for top level menus and f\"Menu:{parent_label|label...}\" for submenus.\n            disabled: Create menu in disabled state. Defaults to False.\n\n        Note:\n            If the menu is created within a MenuBar context manager, the menu will be added to the MenuBar.\n            If the menu is created within a Menu context manager, the menu will be added to the parent Menu as a submenu.\n\n        Examples:\n            ```python\n            import guitk as ui\n\n            class MenuDemo(ui.Window):\n                def config(self):\n                    with ui.VLayout():\n                        ui.Label(\"This window has menus!\")\n\n                    with ui.MenuBar():\n                        with ui.Menu(\"File\"):\n                            ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                            with ui.SubMenu(\"Open Recent\"):\n                                ui.Command(\"File 1\")\n                                ui.Command(\"File 2\")\n                                ui.Command(\"File 3\")\n                            ui.MenuSeparator()\n                            ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                            ui.Command(\"Save As\")\n                        with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                            ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                            ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                            ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n            ```\n        \"\"\"\n        super().__init__(label, disabled=disabled)\n        self._menu = None\n        self._underline = underline\n        self.window = None\n        self._index = 0\n        self.key = key\n\n    def _create_widget(self, parent: tk.Menu, window: Window, path: str | None = None):\n        \"\"\"Create the Menu widget and add it to the parent\n\n        Args:\n            parent: The parent widget\n            window: The Window that owns this Menu\n            path: The path to the parent widget, used only by subclasses\n        \"\"\"\n        debug(\n            f\"Menu._create_widget: {self=} {self._label=} {parent=} {window=} {path=}\"\n        )\n        self.window = window\n        self._parent = parent\n        menu = tk.Menu(parent)\n        if self._underline is None:\n            idx = self._label.find(\"&amp;\")\n            if idx != -1:\n                self._label = self._label.replace(\"&amp;\", \"\", 1)\n                self._underline = idx\n        parent.add_cascade(menu=menu, label=self._label, underline=self._underline)\n\n        self._menu = menu\n        self.key = self.key or path\n        self.path = path or \"\"\n\n        if self._disabled:\n            self.disabled = True\n\n    def _add_widget(self, widget):\n        \"\"\"Add a menu item to the end of the Menu\"\"\"\n        self._menu_list.append(widget)\n\n    def __enter__(self):\n        push_parent(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pop_parent()\n        return False\n\n    def __iter__(self):\n        self._index = 0\n        return iter(self._menu_list)\n\n    def __next__(self) -&gt; Menu | Command:\n        if self._index &gt;= len(self._menu_list):\n            raise StopIteration\n        value = self._menu_list[self._index]\n        self._index += 1\n        return value\n</code></pre>"},{"location":"reference/#guitk.Menu.__init__","title":"<code>__init__(label, underline=None, key=None, disabled=False)</code>","text":"<p>Create a new Menu.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the menu</p> required <code>underline</code> <code>int</code> <p>The index of the character to underline in the label. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>The key to use to access the menu from parent Window. Defaults to  f\"Menu:{label}\" for top level menus and f\"Menu:{parent_label|label...}\" for submenus.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Create menu in disabled state. Defaults to False.</p> <code>False</code> Note <p>If the menu is created within a MenuBar context manager, the menu will be added to the MenuBar. If the menu is created within a Menu context manager, the menu will be added to the parent Menu as a submenu.</p> <p>Examples:</p> <pre><code>import guitk as ui\n\nclass MenuDemo(ui.Window):\n    def config(self):\n        with ui.VLayout():\n            ui.Label(\"This window has menus!\")\n\n        with ui.MenuBar():\n            with ui.Menu(\"File\"):\n                ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                with ui.SubMenu(\"Open Recent\"):\n                    ui.Command(\"File 1\")\n                    ui.Command(\"File 2\")\n                    ui.Command(\"File 3\")\n                ui.MenuSeparator()\n                ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                ui.Command(\"Save As\")\n            with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n</code></pre> Source code in <code>guitk/menu.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    underline: int | None = None,\n    key: Hashable | None = None,\n    disabled: bool = False,\n) -&gt; None:\n    \"\"\"Create a new Menu.\n\n    Args:\n        label (str): The label for the menu\n        underline (int, optional): The index of the character to underline in the label. Defaults to None.\n        key (Hashable, optional): The key to use to access the menu from parent Window.\n            Defaults to  f\"Menu:{label}\" for top level menus and f\"Menu:{parent_label|label...}\" for submenus.\n        disabled: Create menu in disabled state. Defaults to False.\n\n    Note:\n        If the menu is created within a MenuBar context manager, the menu will be added to the MenuBar.\n        If the menu is created within a Menu context manager, the menu will be added to the parent Menu as a submenu.\n\n    Examples:\n        ```python\n        import guitk as ui\n\n        class MenuDemo(ui.Window):\n            def config(self):\n                with ui.VLayout():\n                    ui.Label(\"This window has menus!\")\n\n                with ui.MenuBar():\n                    with ui.Menu(\"File\"):\n                        ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                        with ui.SubMenu(\"Open Recent\"):\n                            ui.Command(\"File 1\")\n                            ui.Command(\"File 2\")\n                            ui.Command(\"File 3\")\n                        ui.MenuSeparator()\n                        ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                        ui.Command(\"Save As\")\n                    with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                        ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                        ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                        ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n        ```\n    \"\"\"\n    super().__init__(label, disabled=disabled)\n    self._menu = None\n    self._underline = underline\n    self.window = None\n    self._index = 0\n    self.key = key\n</code></pre>"},{"location":"reference/#command","title":"Command","text":"<p>               Bases: <code>Menu</code></p> Source code in <code>guitk/menu.py</code> <pre><code>class Command(Menu):\n    def __init__(\n        self,\n        label: str,\n        shortcut: str = None,\n        key: Hashable | None = None,\n        command: CommandType | None = None,\n        disabled: bool = False,\n    ):\n        \"\"\"Create a new menu command\n\n        Args:\n            label (str): The label for the menu command\n            shortcut (str, optional): The shortcut for the menu command\n            key (Hashable, optional): Optional key for the menu command (defaults to the path to the menu command)\n            command (CommandType, optional): The command to run when the menu command is selected\n            disabled (bool): Create command in disabled state. Defaults to False.\n\n        Note:\n            Emits EventType.MenuCommand when command is selected or shortcut is pressed.\n\n        Examples:\n            ```python\n            import guitk as ui\n\n            class MenuDemo(ui.Window):\n                def config(self):\n                    with ui.VLayout():\n                        ui.Label(\"This window has menus!\")\n\n                    with ui.MenuBar():\n                        with ui.Menu(\"File\"):\n                            ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                            with ui.SubMenu(\"Open Recent\"):\n                                ui.Command(\"File 1\")\n                                ui.Command(\"File 2\")\n                                ui.Command(\"File 3\")\n                            ui.MenuSeparator()\n                            ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                            ui.Command(\"Save As\")\n                        with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                            ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                            ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                            ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n            ```\n        \"\"\"\n        super().__init__(label, disabled=disabled)\n        self.shortcut = shortcut\n        self._parent = None\n        self.key = key\n        self._command = command\n\n    def _create_widget(self, parent: tk.Menu, window: Window, path: str):\n        \"\"\"Create the Menu widget and add it to the parent\n\n        Args:\n            parent: The parent widget\n            window: The Window that owns this Menu\n            path: The path to the parent widget, used as the key for the command\n        \"\"\"\n        debug(f\"Command._create_widget: {self=} {parent=} {window=} {path=}\")\n        self._parent = parent\n        self.window = window\n        self.key = self.key or path\n        self.path = path or \"\"\n\n        parent.add_command(\n            label=self._label,\n            command=self.window._make_callback(\n                Event(self, self.window, self.key, EventType.MenuCommand)\n            ),\n            accelerator=self.shortcut,\n        )\n\n        if self._command:\n            self.window.bind_command(\n                key=self.key, event_type=EventType.MenuCommand, command=self._command\n            )\n\n        if self._disabled:\n            self.disabled = True\n\n        key_binding = _map_key_binding_from_shortcut(self.shortcut)\n\n        def _make_callback(event):\n            def _callback(*arg):\n                if self._self_or_ancestor_is_disabled():\n                    # if self or any ancestor is disabled, ignore the shortcut event\n                    return\n                if arg:\n                    event.event = arg[0]\n                self.window._handle_event(event)\n\n            return _callback\n\n        window.window.bind_all(\n            key_binding,\n            _make_callback(Event(self, self.window, self.key, EventType.MenuCommand)),\n        )\n</code></pre>"},{"location":"reference/#guitk.Command.__init__","title":"<code>__init__(label, shortcut=None, key=None, command=None, disabled=False)</code>","text":"<p>Create a new menu command</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the menu command</p> required <code>shortcut</code> <code>str</code> <p>The shortcut for the menu command</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Optional key for the menu command (defaults to the path to the menu command)</p> <code>None</code> <code>command</code> <code>CommandType</code> <p>The command to run when the menu command is selected</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Create command in disabled state. Defaults to False.</p> <code>False</code> Note <p>Emits EventType.MenuCommand when command is selected or shortcut is pressed.</p> <p>Examples:</p> <pre><code>import guitk as ui\n\nclass MenuDemo(ui.Window):\n    def config(self):\n        with ui.VLayout():\n            ui.Label(\"This window has menus!\")\n\n        with ui.MenuBar():\n            with ui.Menu(\"File\"):\n                ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                with ui.SubMenu(\"Open Recent\"):\n                    ui.Command(\"File 1\")\n                    ui.Command(\"File 2\")\n                    ui.Command(\"File 3\")\n                ui.MenuSeparator()\n                ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                ui.Command(\"Save As\")\n            with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n</code></pre> Source code in <code>guitk/menu.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    shortcut: str = None,\n    key: Hashable | None = None,\n    command: CommandType | None = None,\n    disabled: bool = False,\n):\n    \"\"\"Create a new menu command\n\n    Args:\n        label (str): The label for the menu command\n        shortcut (str, optional): The shortcut for the menu command\n        key (Hashable, optional): Optional key for the menu command (defaults to the path to the menu command)\n        command (CommandType, optional): The command to run when the menu command is selected\n        disabled (bool): Create command in disabled state. Defaults to False.\n\n    Note:\n        Emits EventType.MenuCommand when command is selected or shortcut is pressed.\n\n    Examples:\n        ```python\n        import guitk as ui\n\n        class MenuDemo(ui.Window):\n            def config(self):\n                with ui.VLayout():\n                    ui.Label(\"This window has menus!\")\n\n                with ui.MenuBar():\n                    with ui.Menu(\"File\"):\n                        ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                        with ui.SubMenu(\"Open Recent\"):\n                            ui.Command(\"File 1\")\n                            ui.Command(\"File 2\")\n                            ui.Command(\"File 3\")\n                        ui.MenuSeparator()\n                        ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                        ui.Command(\"Save As\")\n                    with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                        ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                        ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                        ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n        ```\n    \"\"\"\n    super().__init__(label, disabled=disabled)\n    self.shortcut = shortcut\n    self._parent = None\n    self.key = key\n    self._command = command\n</code></pre>"},{"location":"reference/#menuseparator","title":"MenuSeparator","text":"<p>               Bases: <code>Menu</code></p> <p>Separator that adds a dividing line between menu items.</p> <p>Examples:</p> <pre><code>import guitk as ui\n\nclass MenuDemo(ui.Window):\n    def config(self):\n        with ui.VLayout():\n            ui.Label(\"This window has menus!\")\n\n        with ui.MenuBar():\n            with ui.Menu(\"File\"):\n                ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                with ui.SubMenu(\"Open Recent\"):\n                    ui.Command(\"File 1\")\n                    ui.Command(\"File 2\")\n                    ui.Command(\"File 3\")\n                ui.MenuSeparator()\n                ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                ui.Command(\"Save As\")\n            with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n</code></pre> Source code in <code>guitk/menu.py</code> <pre><code>class MenuSeparator(Menu):\n    \"\"\"Separator that adds a dividing line between menu items.\n\n    Examples:\n        ```python\n        import guitk as ui\n\n        class MenuDemo(ui.Window):\n            def config(self):\n                with ui.VLayout():\n                    ui.Label(\"This window has menus!\")\n\n                with ui.MenuBar():\n                    with ui.Menu(\"File\"):\n                        ui.Command(\"Open...\", shortcut=\"Ctrl+O\")\n                        with ui.SubMenu(\"Open Recent\"):\n                            ui.Command(\"File 1\")\n                            ui.Command(\"File 2\")\n                            ui.Command(\"File 3\")\n                        ui.MenuSeparator()\n                        ui.Command(\"Save\", key=\"File|Save\", disabled=True)\n                        ui.Command(\"Save As\")\n                    with ui.Menu(\"Edit\", key=\"Edit\", disabled=True):\n                        ui.Command(\"Cut\", shortcut=\"Ctrl+X\")\n                        ui.Command(\"Copy\", shortcut=\"Ctrl+C\")\n                        ui.Command(\"Paste\", shortcut=\"Ctrl+V\")\n        ```\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create a new MenuSeparator\"\"\"\n        super().__init__(\"\")\n\n    def _create_widget(self, parent: tk.Menu, window: Window, path: str | None = None):\n        \"\"\"Create the Separator widget and add it to the parent\n\n        Args:\n            parent: The parent widget\n            window: The Window that owns this Menu\n            path: The path to the parent widget, used as the key for the command\n        \"\"\"\n        debug(f\"MenuSeparator._create_widget: {self=} {parent=} {window=} {path=}\")\n        self._parent = parent\n        self.window = window\n        parent.add_separator()\n        self.key = f\"{path}separator({id(self)})\"\n        self.path = path or \"\"\n</code></pre>"},{"location":"reference/#guitk.MenuSeparator.__init__","title":"<code>__init__()</code>","text":"<p>Create a new MenuSeparator</p> Source code in <code>guitk/menu.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a new MenuSeparator\"\"\"\n    super().__init__(\"\")\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#guitk-tutorial","title":"GUITk Tutorial","text":""},{"location":"tutorial/#overview-of-the-guitk-library","title":"Overview of the GUITk Library","text":"<p>GUITk is a declarative framework, built on tkinter, for building nice-looking, cross-platform GUIs in Python. The goal of GUITk is to make it easy to build GUIs without knowing a lot about tkinter. The GUITk object model is partially inspired by SwiftUI.</p> <p>GUITk wraps tkinter widgets in GUITk objects. Instead of the standard tkinter geometry managers (pack,  grid, place), GUITk uses declarative layout objects to place widgets in a window. GUITk also provides a declarative</p>"},{"location":"tutorial/#why-tkinter","title":"Why tkinter?","text":"<p>GUITk builds on tkinter because tkinter is a mature, stable, cross-platform GUI framework that is included in the Python standard library. tkinter was first added to Python 1.4 in 1996 and runs on most platforms. It is not, however, the easiest to use nor the most pythonic GUI framework. GUITk aims to make it easier to build GUIs with tkinter. Standard tkinter widgets look somewhat dated but tkinter includes themed widgets (ttk) that look much better. GUITk uses ttk widgets whenever possible.</p>"},{"location":"tutorial/#basic-concepts","title":"Basic Concepts","text":"<p>Let's start with an example. The following \"hello world\" example creates a window with a label, a text entry box, and a button. When the user presses Return or clicks the button, a greeting is printed to the console.</p> <p></p> <pre><code>\"\"\"Simple Hello World example using guitk \"\"\"\n\nimport guitk as ui\n\n\n# subclass guitk.Window as the starting point for your app's main window\nclass HelloWindow(ui.Window):\n    def config(self):\n        \"\"\"Configure the window\"\"\"\n\n        # set the window title\n        self.title = \"Hello, World\"\n\n        # define a layout for the window\n        # the layout manager will automatically add widgets to the window\n        with ui.HLayout():\n            ui.Label(\"What's your name?\")\n            ui.Entry(key=\"name\", focus=True)\n            ui.Button(\"Ok\", key=\"ok\")\n\n    @ui.on(key=\"ok\")\n    def on_ok(self, event: ui.Event):\n        \"\"\"Handle the Ok button click\"\"\"\n        print(\"Hello, \", self.get(\"name\").value)\n\n\n# run your event loop\nif __name__ == \"__main__\":\n    HelloWindow().run()\n</code></pre> <p>A few things to note about this example:</p> <ul> <li>The <code>HelloWindow</code> class subclasses <code>guitk.Window</code>. This is the starting point for your app's main window.</li> <li>The <code>HelloWindow</code> class defines a <code>config</code> method that configures the window. <code>config()</code> is a special method    that is called by GUITk before the window is created. It is used to configure the window's title, size, and    widgets. Your window class must define a <code>config()</code> method.</li> <li>Widgets are added to your window using a layout manager. Creating an instance of a layout manager within your    <code>config()</code> method adds it to the window. The <code>HelloWindow</code> class uses an <code>HLayout()</code> layout manager which     arranges widgets horizontally.</li> <li>Widgets, such as <code>Label</code> (static text), <code>Entry</code> (text entry box), and <code>Button</code>, are added to the window by    creating instances of them within the context of the layout manager.</li> <li>Every widget has an optional key, which is a unique identifier for the widget. In this example, the \"Ok\" button    has a key of \"ok\".</li> <li>Events (such as a button press) are handled using the <code>@on()</code> decorator. The <code>@on()</code> decorator is used to    register a callback function that is called when the event occurs. In this example, the <code>on_ok()</code> function     is called when the user presses Return or clicks the \"Ok\" button (because the button has a key of \"ok\" which     the <code>on_ok()</code> function is registered to handle).</li> </ul>"},{"location":"tutorial/#creating-a-window","title":"Creating a Window","text":"<p>Every GUITk app must have at least one class that subclasses <code>guitk.Window</code>. This class is the starting point for your app's main window. An app may have multiple windows but one of them must be the main window. The main window is created by calling the <code>run()</code> method on the window class. The <code>run()</code> method starts the main event loop and displays the window.</p> <p>The <code>Window</code> class has a <code>config()</code> method that is called by GUITk before the window is created. You must define a <code>config()</code> method in your window class in order to display any widgets in the window (and without widgets, your window would be a pretty boring GUI). The config method will be automatically called by GUITk before the window is displayed. You should not need to create an <code>__init__()</code> method in your window class as all configuration is done in the <code>config()</code> method.</p> <p>Here is a minimal window class:</p> <p></p> <pre><code>\"\"\"Minimal example of a GUITk Window\"\"\"\n\nimport guitk as ui\n\n\nclass MinimalWindow(ui.Window):\n    def config(self):\n        with ui.VLayout():\n            ui.Label(\"Hello World!\")\n\n\nif __name__ == \"__main__\":\n    MinimalWindow().run()\n</code></pre>"},{"location":"tutorial/#window-configuration","title":"Window Configuration","text":"<p>The <code>config()</code> method is used to configure the window. When subclassing <code>guitk.Window</code>, you must define a <code>config()</code> method. You do not need to call the <code>config()</code> method yourself nor should you call the superclass <code>config()</code> method. GUITk will call <code>config()</code> for you before the window is created.</p> <p>In <code>config()</code>, you can set the title and size of the window and create your layout by creating an instance of GUITk Layout Manager.</p> <p>For example, here is a window with a title and size:</p> <pre><code>class MyWindow(guitk.Window):\n    def config(self):\n        self.title = \"My Window\"\n        self.size = (400, 300)\n</code></pre> <p>Window size (in pixels) can be set as a tuple of (width, height) or as a string in the form \"widthxheight\" (e.g. \"400x300\"). Consistent with tkinter, the window size can also be set by setting <code>self.geometry</code>:</p> <pre><code>class MyWindow(guitk.Window):\n    def config(self):\n        self.title = \"My Window\"\n        self.geometry = \"400x300\"\n</code></pre> <p>Layouts are covered in more detail in the next section.</p>"},{"location":"tutorial/#window-methods","title":"Window Methods","text":"<p>In addition to the <code>config()</code> method, you can define the following methods in your window class and if defined, they will be called by GUITk:</p> <p><code>setup(self) -&gt; None</code> - called after the window is created (after <code>config()</code>) but before it is displayed. This is a good place to initialize your app's state. If you need to access any of the underlying tkinter widgets, you can do so in <code>setup()</code> as the widgets will have been created by this point.</p> <p><code>teardown(self) -&gt; None</code> - called when the window is closed. This is a good place to clean up any resources used by your app.</p> <p><code>handle_event(self, event: guitk.Event) -&gt; None</code> - called when an event occurs. This is a good place to handle events that are not handled by widgets or by the <code>@on()</code> decorator. The GUITk event system is covered in more detail in a later section.</p> <p>Here's an example of a window with a title and size and the <code>setup()</code>, <code>teardown()</code>, and <code>handle_event()</code> methods defined:</p> <pre><code>\"\"\"Hello World example using guitk \"\"\"\n\nimport guitk as ui\n\n\nclass HelloWorld(ui.Window):\n    # subclass guitk.Window as the starting point for your app's main window\n    def config(self):\n        # Your Window class needs to define a config() method that describes the layout, title, etc for your app\n        # config() is called by the Window class when the Window is being created\n\n        # Title for the window\n        self.title = \"Hello, World\"\n\n        # optionally set size as a tuple of (width, height)\n        self.size = (320, 240)\n\n        # you can also use self.geometry for consistency with tkinter\n        # self.geometry = \"320x240\"\n\n        # Define the window's contents\n        # guitk.Label corresponds to a tkinter.ttk.Label, etc.\n        # optionally provide a unique key to each element to easily reference the element later\n        # use a HLayout or VLayout class to define the layout of the window\n        # HLayout arranges widgets horizontally, VLayout arranges widgets vertically\n        with ui.VLayout():\n            # use a VLayout to stack the widgets vertically\n            # standard tkinter layout options such as sticky and weight are supported\n            ui.Label(\"What's your name?\", sticky=\"ew\", anchor=\"center\", weightx=1)\n            # each widget can be assigned a key, which should be unique, to easily reference the widget later\n            # set focus=True so the Entry box has focus when the window is displayed\n            ui.Entry(key=\"entry_name\", focus=True, weightx=1, sticky=\"ew\")\n            ui.Label(\"\", width=40, key=\"output\")\n            with ui.HStack():\n                # align these two buttons in a horizontal row using HStack\n                ui.Button(\"Ok\")\n                ui.Button(\"Quit\")\n\n    # Every Window class has 3 special methods that can be overridden to provide custom behavior\n    # you do not need to provide any of these methods if you do not need to customize the default behavior\n    # (the default behavior is to do nothing)\n    # These special methods are: setup(), teardown(), and handle_event()\n\n    def setup(self):\n        \"\"\"Perform any initialization needed before the Window is displayed\"\"\"\n        # your setup() method is called by the Window class after config() just before the Window is displayed\n        # use this to initialize any internal state you need\n        # you do not need to provide a setup() method if no initialization is needed\n        print(\"setup\")\n\n    def teardown(self):\n        \"\"\"Perform any cleanup needed before destroying the window\"\"\"\n        # your teardown() method is called by the Window class after the Window is closed\n        # use this to clean up before the Window is destroyed\n        # you do not need to provide a teardown() method if no cleanup is needed\n        print(\"teardown\")\n\n    def handle_event(self, event: ui.Event):\n        \"\"\"handle_event() is called by the Window class when an event occurs\"\"\"\n        # you do not need to provide a handle_event() method if you prefer to use\n        # the @on decorator to bind functions to events (see below)\n        # handle_event() is a useful place to put code that needs to run for every event\n        # or for use during debugging\n        print(f\"handle_event: {event}\")\n\n    @ui.on(key=\"Quit\")\n    def on_quit(self):\n        # return the value of the Entry box\n        self.quit(self[\"entry_name\"].value)\n\n    @ui.on(key=\"Ok\")\n    @ui.on(event_type=ui.EventType.EntryReturn)\n    def on_ok(self):\n        # User pressed the OK button or the Return key inside the Entry box\n        # the @on decorator can be used to bind a function to an event\n        # @on can be repeated to bind the function to multiple events\n        # set the output Label to the value of the Entry box\n        # individual widgets can be accessed by their key; the window object acts as a dictionary of widgets\n        greeting = f\"Hello {self['entry_name'].value}! Thanks for trying guitk.\"\n\n        # if you prefer, you can use get() instead of the dictionary syntax\n        self.get(\"output\").value = greeting\n\n\nif __name__ == \"__main__\":\n    # instantiate your Window class and run it\n    name = HelloWorld().run()\n    print(f\"Hello {name}\")\n</code></pre>"},{"location":"tutorial/#starting-the-app","title":"Starting the App","text":"<p>Once you have defined your window class, you can start the app by calling the <code>run()</code> method on the window class:</p> <pre><code>MyWindow.run()\n</code></pre> <p>This creates the window and starts the tkinter event loop. The <code>run()</code> method does not return until the window is closed. Child windows may be created in your class by creating an instance of a window class, for example, <code>child = MyChildWindow()</code>, but you should call <code>run()</code> only on the main window.</p>"},{"location":"tutorial/#layouts","title":"Layouts","text":""},{"location":"tutorial/#events","title":"Events","text":""},{"location":"tutorial/#todo-finish-tutorial","title":"TODO: finish tutorial","text":"<p>This tutorial is a work in progress. More to come soon...</p>"}]}