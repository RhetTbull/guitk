{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GUITk's documentation!","text":"<p>Python GUI Toolkit for Tk (guitk): simplify the layout and construction of tkinter graphical user interfaces in python.</p> <p>For full documentation visit GUITk.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install guitk</code></p>"},{"location":"#source-code","title":"Source Code","text":"<p>GUITk on GitHub</p>"},{"location":"#license","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2020 Rhet Turnbull, All rights reserved.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#window","title":"Window","text":"<p>         Bases: <code>_LayoutMixin</code>, <code>_WindowBaseClass</code></p> <p>Basic Window class from which all windows are derived</p> Notes <p>Classes which inherit from window should implement handle_event, setup, and teardown as needed</p> Source code in <code>guitk/window.py</code> <pre><code>class Window(_LayoutMixin, _WindowBaseClass):\n\"\"\"Basic Window class from which all windows are derived\n\n    Notes:\n        Classes which inherit from window should implement handle_event, setup, and teardown as needed\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: tk.Tk | None = None,\n        title: str | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        topmost: bool | None = None,\n        autoframe: bool = False,\n        theme: str | None = None,\n        tooltip: TooltipType | None = None,\n        modal: bool | None = None,\n        size: SizeType = None,\n    ):\n        # call _config then subclass's config to initialize\n        # layout, title, menu, etc.\n\n        self.autoframe = autoframe\n\n        self._config()\n        self.config()\n\n        # override any layout defaults from constructor\n        self.title: str | None = title if title is not None else self.title\n        self.padx: int | None = padx if padx is not None else self.padx\n        self.pady: int | None = pady if pady is not None else self.pady\n        self.theme: str | None = theme if theme is not None else self.theme\n        self.tooltip: TooltipType | None = (\n            tooltip if tooltip is not None else self.tooltip\n        )\n        self.modal: bool | None = modal if modal is not None else self.modal\n        self.size: SizeType = size if size is not None else self.size\n\n        self._id: int = id(self)\n        self._tk: _TKRoot = _TKRoot()\n        self._parent = parent or self._tk.root\n        self._topmost = topmost\n\n        self.window: tk.TopLevel = tk.Toplevel(self._parent)\n        self.window.title(self.title)\n        self._widgets = []\n        self._widget_by_key = {}\n\n        self._timer_events = {}\n\"\"\" timer events that have been set by bind_timer_event, stores most recent after() id for event\"\"\"\n\n        self._timer_events_cancelled = {}\n\"\"\" timer events that have been set by bind_timer_event but then cancelled \"\"\"\n\n        self._return_value = None\n\"\"\" value returned from run() if set in quit() \"\"\"\n\n        self._root_menu = None\n\"\"\" will hold root tk.Menu widget\"\"\"\n\n        self._radiobuttons = {}\n\"\"\" will hold group name/variable for radio buttons in the window \"\"\"\n\n        self._mainframe = ttk.Frame(self.window, padding=\"3 3 12 12\")\n        self._mainframe.grid(column=0, row=0, sticky=\"nsew\")\n        self.window.columnconfigure(0, weight=1)\n        self.window.rowconfigure(0, weight=1)\n\n        self._tk.register(self)\n        self.window.protocol(\n            \"WM_DELETE_WINDOW\",\n            self._make_callback(Event(self, self, EventType.Quit, EventType.Quit)),\n        )\n\n        if not self.layout:\n            self.layout = [\n                [\n                    Label(\n                        \"Looks like you forgot to include a layout in your class definition\"\n                    )\n                ]\n            ]\n\n        self._commands = []\n\n        self._layout(self._mainframe, self)\n\n        # apply theme if necessary\n        if self.theme is not None:\n            self._tk.theme = self.theme\n\n        self._grid_configure_widgets()\n\n        if self.menu:\n            self._build_menu()\n\n        if self._topmost or self.modal:\n            self.window.attributes(\"-topmost\", 1)\n\n        if self.modal:\n            windowingsystem = self.root.call(\"tk\", \"windowingsystem\")\n            if windowingsystem == \"aqua\":\n                with contextlib.suppress(Exception):\n                    self.root.call(\n                        \"::tk::unsupported::MacWindowStyle\",\n                        \"style\",\n                        self._w,\n                        \"moveableModal\",\n                        \"\",\n                    )\n            if self._parent is not None and self._parent.winfo_viewable():\n                self.window.transient(self._parent)\n            self.window.wait_visibility()\n            self.window.grab_set()\n\n        if self.size is not None:\n            size = (\n                self.size\n                if isinstance(self.size, str)\n                else f\"{self.size[0]}x{self.size[1]}\"\n            )\n            self.window.geometry(size)\n\n        # TODO: add geometry code to ensure window appears in good spot relative to parent\n\n        self.events = True\n\n        self._bind_timer_event(\n            100, EventType.WindowFinishedLoading.value, EventType.WindowFinishedLoading\n        )\n\n        self._bind_event_handlers()\n\n        self.setup()\n\n        if self.modal:\n            self.window.wait_window()\n\n    def _grid_configure_widgets(self):\n\"\"\"Apply padding to all widgets in the window\"\"\"\n        # apply padding, widget padding takes precedent over window\n        for widget in self._widgets:\n            padx = widget.padx if widget.padx is not None else self.padx\n            pady = widget.pady if widget.pady is not None else self.pady\n            widget.widget.grid_configure(padx=padx, pady=pady)\n\n    def _config(self):\n        self.title = \"My Window\"\n\"\"\"Title to display in the window's title bar \"\"\"\n\n        self.layout = []\n\"\"\"Every class that inherits from Window must define it's own layout \"\"\"\n\n        self.menu = {}\n\"\"\" Optionally provide a menu \"\"\"\n\n        self.padx = DEFAULT_PADX\n        self.pady = DEFAULT_PADY\n\"\"\"Default padding around widgets \"\"\"\n\n        self.theme = None\n\"\"\"The ttk theme to use, if None, uses ttk default\"\"\"\n\n        self.tooltip = None\n\"\"\" A callable which returns the tooltip text for a given key or a str \"\"\"\n\n        self.modal = False\n\"\"\" Set to True to create modal window \"\"\"\n\n        self.size = None\n\"\"\" Set to a tuple of (width, height) to set the window size \"\"\"\n\n        push_parent(self)\n\n    def config(self):\n        pass\n\n    def handle_event(self, event: Event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n        if event.event_type == EventType.Quit:\n            self.quit(self._return_value)\n\n    def setup(self):\n\"\"\"Perform any needed setup for the window.\n        Gets called immediately after __init__\n        \"\"\"\n        pass\n\n    def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n        Gets called immediately before the window is destroyed\n        \"\"\"\n        pass\n\n    def quit(self, return_value: Any = None):\n\"\"\"Close the window\"\"\"\n        self._return_value = return_value\n        self._destroy()\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        self._title = value\n\n    def bind_command(self, key=None, event_type=None, command=None):\n        if not any([key, event_type]):\n            raise ValueError(\"At least one of key, event_type must be specified\")\n        self._bind_command(\n            EventCommand(widget=None, key=key, event_type=event_type, command=command)\n        )\n\n    def _bind_command(self, event_command: EventCommand):\n        self._commands.append(event_command)\n\n    def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n        repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n        if command:\n            self.bind_command(\n                key=event_name, event_type=EventType.VirtualEvent, command=command\n            )\n        return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n\n    def _bind_timer_event(self, delay, event_name, event_type, repeat=False):\n        # create a unique name for the timer\n        timer_id = f\"{event_name}_{time.time_ns()}\"\n\n        # callback that generates event and respawns the timer if repeat=True\n        # when cancelling with cancel_timer_event, sometimes the call to after_cancel doesn't apparently work so check\n        # if timer_id is in _timer_events_cancelled before respawning\n        def _generate_event():\n            self.root.event_generate(event_name)\n            if repeat and timer_id not in self._timer_events_cancelled:\n                self._timer_events[timer_id] = self._tk.root.after(\n                    delay, _generate_event\n                )\n\n        event = Event(self, self, event_name, event_type)\n        self.root.bind(event_name, self._make_callback(event))\n        self._timer_events[timer_id] = self._tk.root.after(delay, _generate_event)\n        return timer_id\n\n    def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n        try:\n            after_id = self._timer_events[timer_id]\n            self.root.after_cancel(after_id)\n            self._timer_events.pop(timer_id)\n            self._timer_events_cancelled[timer_id] = after_id\n        except KeyError as e:\n            raise ValueError(f\"Timer event {timer_id} not found\") from e\n        except Exception as e:\n            raise e\n\n    def _bind_event_handlers(self):\n\"\"\"Bind any event handlers decorated with @on\"\"\"\n        for method in self.__class__.__dict__.values():\n            if hasattr(method, \"_guitk_event_handlers\"):\n                for key, event_type in getattr(method, \"_guitk_event_handlers\"):\n                    self.bind_command(key=key, event_type=event_type, command=method)\n\n    def add_widget(self, widget: Widget, row: int, col: int):\n\"\"\"Add a widget to the window's mainframe\"\"\"\n        widget._create_widget(self._mainframe, self, row, col)\n        self._widgets.append(widget)\n        self._widget_by_key[widget.key] = widget\n        self._grid_configure_widgets()\n\n    def remove(self, key_or_widget: Hashable | Widget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n        for idx, widget in enumerate(self._widgets):\n            debug(f\"{idx=} {widget=} {key_or_widget=}\")\n            if widget == key_or_widget or widget.key == key_or_widget:\n                widget = self._widgets[idx]\n                if widget.parent == self:\n                    self._remove(widget)\n                else:\n                    widget.parent.remove(widget)\n                return\n        raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n\n    def _remove(self, widget: Widget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n        widget.widget.grid_forget()\n        widget.widget.destroy()\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n        self.window.update_idletasks()\n\n    def _insert_widget_row_col(self, widget: Widget, row: int, col: int):\n\"\"\"Insert a widget into the window's mainframe after the container has been created\n            Intended for use at run-time only when widgets need to be added dynamically\n\n        Args:\n            widget: (Widget) the widget to add\n            row: (int) the row to insert the widget into\n            col: (int) the column to insert the widget into\n\n        Note:\n            This method is included in Window so that Widget.replace() works properly for\n            widgets added directly to a layout. It does not expand the layout like the similar\n            method in _Container.\n        \"\"\"\n        # TODO: fix this so it actually inserts instead of replaces\n        self.add_widget(widget, row, col)\n\n    def run(self):\n        self._tk.run_mainloop()\n        return self._return_value\n\n    @property\n    def root(self):\n\"\"\"Return Tk root instance\"\"\"\n        return self._tk.root\n\n    @property\n    def widgets(self) -&gt; list[Widget]:\n\"\"\" \"Return list of all widgets belonging to the window\"\"\"\n        return self._widgets\n\n    def children(self):\n\"\"\"Return child windows\"\"\"\n        return self._tk.get_children(self)\n\n    def get(self, key: Hashable):\n\"\"\"Get widget with key or raise KeyError if not found\"\"\"\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Widget with key {key} not found\") from e\n\n    def _add_widget(self, widget: Widget):\n\"\"\"Dummy method to allow widgets to be added with VLayout()/HLayout()\"\"\"\n        pass\n\n    def _forget_widget(self, widget: Widget):\n\"\"\"Remove widget from the window's bookkeeping but don't destroy it\"\"\"\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n\n    def _add_menus(self, menu: Menu, menu_items, path=None):\n        path = f\"MENU:{menu._label}\" if path is None else path\n        for m in menu_items:\n            if type(m) == dict:\n                # submenu\n                for subm in m:\n                    subm._create_widget(menu._menu, self)\n                    subpath = f\"{path}|{subm._label}\"\n                    self._add_menus(subm, m[subm], subpath)\n            elif isinstance(m, Command):\n                command_path = f\"{path}|{m._label}\"\n                m._create_widget(menu._menu, self, command_path)\n\n    def _build_menu(self):\n        if type(self.menu) != dict:\n            raise ValueError(\"self.menu must be a dict\")\n\n        if self._root_menu is None:\n            # create the root menu\n            self.root.option_add(\"*tearOff\", tk.FALSE)\n            self._root_menu = tk.Menu(self.root)\n            self.window[\"menu\"] = self._root_menu\n\n        for m in self.menu:\n            if not isinstance(m, Menu):\n                raise ValueError(\"self.menu keys must be Menu objects\")\n            m._create_widget(self._root_menu, self)\n            self._add_menus(m, self.menu[m])\n\n    def _destroy(self):\n        # call teardown to perform any cleanup\n        self.teardown()\n\n        # kill any child windows\n        for child in self.children():\n            event = Event(child, child.window, EventType.Quit, EventType.Quit)\n            child.handle_event(event)\n            with contextlib.suppress(Exception):\n                child._destroy()\n\n        # disable event processing in _handle_event\n        self.events = False\n\n        # disable any stdout/stderr redirection and event handling\n        for widget in self._widgets:\n            widget.events = False\n\n            if \"guitk.widgets.tk_text.Output\" in str(type(widget)):\n                widget.disable_redirect()\n\n        if self.modal:\n            self.window.grab_release()\n\n        # cancel any timer events\n        for timer_id in self._timer_events:\n            with contextlib.suppress(Exception):\n                after_id = self._timer_events[timer_id]\n                self._tk.root.after_cancel(after_id)\n        self._parent.focus_set()\n        self.window.destroy()\n        self._tk.deregister(self)\n\n    def _make_callback(self, event):\n        def _callback(*arg):\n            if arg:\n                event.event = arg[0]\n            self._handle_event(event)\n\n        return _callback\n\n    def _handle_event(self, event):\n\"\"\"Handle events for this window\"\"\"\n\n        # only handle events if widget has events=True; Window objects always get events\n        if isinstance(event.widget, (Widget, Window)) and not event.widget.events:\n            return\n\n        # filter events for this window\n        if event.id == self._id:\n            # handle custom commands\n            self._handle_commands(event)\n\n            self.handle_event(event)\n\n            # if deleting the window, call _destroy after handle_event has had a chance to handle it\n            if event.event_type == EventType.Quit:\n                self._destroy()\n\n    def _handle_commands(self, event):\n\"\"\"Handle commands bound to widgets in the window\"\"\"\n        for command in self._commands:\n            if (\n                (command.widget is None or command.widget == event.widget)\n                and (command.key is None or command.key == event.key)\n                and (\n                    command.event_type is None or command.event_type == event.event_type\n                )\n            ):\n                if hasattr(command.command, \"_guitk_event_handlers\"):\n                    # command was decorated with @on, so it's a method of this class\n                    if len(inspect.signature(command.command).parameters) == 2:\n                        # command has a second argument, assume it's the event\n                        command.command(self, event)\n                    else:\n                        command.command(self)\n                else:\n                    command.command()\n\n    def __getitem__(self, key) -&gt; \"Widget\":\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Invalid key: no widget with key {key}\") from e\n</code></pre>"},{"location":"reference/#guitk.window.Window.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return Tk root instance</p>"},{"location":"reference/#guitk.window.Window.widgets","title":"<code>widgets: list[Widget]</code>  <code>property</code>","text":"<p>\"Return list of all widgets belonging to the window</p>"},{"location":"reference/#guitk.window.Window.add_widget","title":"<code>add_widget(widget, row, col)</code>","text":"<p>Add a widget to the window's mainframe</p> Source code in <code>guitk/window.py</code> <pre><code>def add_widget(self, widget: Widget, row: int, col: int):\n\"\"\"Add a widget to the window's mainframe\"\"\"\n    widget._create_widget(self._mainframe, self, row, col)\n    self._widgets.append(widget)\n    self._widget_by_key[widget.key] = widget\n    self._grid_configure_widgets()\n</code></pre>"},{"location":"reference/#guitk.window.Window.bind_timer_event","title":"<code>bind_timer_event(delay, event_name, repeat=False, command=None)</code>","text":"<p>Create a new virtual event <code>event_name</code> that fires after <code>delay</code> ms, repeats every <code>delay</code> ms if repeat=True, otherwise fires once</p> Source code in <code>guitk/window.py</code> <pre><code>def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n    repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n    if command:\n        self.bind_command(\n            key=event_name, event_type=EventType.VirtualEvent, command=command\n        )\n    return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n</code></pre>"},{"location":"reference/#guitk.window.Window.cancel_timer_event","title":"<code>cancel_timer_event(timer_id)</code>","text":"<p>Cancel a timer event created with bind_timer_event</p> Source code in <code>guitk/window.py</code> <pre><code>def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n    try:\n        after_id = self._timer_events[timer_id]\n        self.root.after_cancel(after_id)\n        self._timer_events.pop(timer_id)\n        self._timer_events_cancelled[timer_id] = after_id\n    except KeyError as e:\n        raise ValueError(f\"Timer event {timer_id} not found\") from e\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"reference/#guitk.window.Window.children","title":"<code>children()</code>","text":"<p>Return child windows</p> Source code in <code>guitk/window.py</code> <pre><code>def children(self):\n\"\"\"Return child windows\"\"\"\n    return self._tk.get_children(self)\n</code></pre>"},{"location":"reference/#guitk.window.Window.get","title":"<code>get(key)</code>","text":"<p>Get widget with key or raise KeyError if not found</p> Source code in <code>guitk/window.py</code> <pre><code>def get(self, key: Hashable):\n\"\"\"Get widget with key or raise KeyError if not found\"\"\"\n    try:\n        return self._widget_by_key[key]\n    except KeyError as e:\n        raise KeyError(f\"Widget with key {key} not found\") from e\n</code></pre>"},{"location":"reference/#guitk.window.Window.handle_event","title":"<code>handle_event(event)</code>","text":"<p>Handle event objects, inheriting classes should implement handle_event</p> Source code in <code>guitk/window.py</code> <pre><code>def handle_event(self, event: Event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n    if event.event_type == EventType.Quit:\n        self.quit(self._return_value)\n</code></pre>"},{"location":"reference/#guitk.window.Window.quit","title":"<code>quit(return_value=None)</code>","text":"<p>Close the window</p> Source code in <code>guitk/window.py</code> <pre><code>def quit(self, return_value: Any = None):\n\"\"\"Close the window\"\"\"\n    self._return_value = return_value\n    self._destroy()\n</code></pre>"},{"location":"reference/#guitk.window.Window.remove","title":"<code>remove(key_or_widget)</code>","text":"<p>Remove widget from window and destroy it.</p> Source code in <code>guitk/window.py</code> <pre><code>def remove(self, key_or_widget: Hashable | Widget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n    for idx, widget in enumerate(self._widgets):\n        debug(f\"{idx=} {widget=} {key_or_widget=}\")\n        if widget == key_or_widget or widget.key == key_or_widget:\n            widget = self._widgets[idx]\n            if widget.parent == self:\n                self._remove(widget)\n            else:\n                widget.parent.remove(widget)\n            return\n    raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n</code></pre>"},{"location":"reference/#guitk.window.Window.setup","title":"<code>setup()</code>","text":"<p>Perform any needed setup for the window. Gets called immediately after init</p> Source code in <code>guitk/window.py</code> <pre><code>def setup(self):\n\"\"\"Perform any needed setup for the window.\n    Gets called immediately after __init__\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#guitk.window.Window.teardown","title":"<code>teardown()</code>","text":"<p>Perform any cleanup before the window closes. Gets called immediately before the window is destroyed</p> Source code in <code>guitk/window.py</code> <pre><code>def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n    Gets called immediately before the window is destroyed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#button","title":"Button","text":"<p>         Bases: <code>Widget</code></p> <p>Basic button</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class Button(Widget):\n\"\"\"Basic button\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a Button widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n            **kwargs,\n        )\n\n        self.widget_type = \"ttk.Button\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tooltip = tooltip\n        self.padx = padx\n        self.pady = pady\n        self.kwargs = kwargs\n\n    @property\n    def value(self) -&gt; str:\n        return self.widget[\"text\"]\n\n    @value.setter\n    def value(self, text: str):\n        self.widget[\"text\"] = text\n\n    def _create_widget(self, parent: Any, window: Window, row: int, col: int):\n        event = Event(self, window, self.key, EventType.ButtonPress)\n\n        # build arg list for Button()\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n\n        self.widget = ttk.Button(\n            parent,\n            text=self.text,\n            command=window._make_callback(event),\n            **kwargs_button,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ButtonPress,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def button(self):\n\"\"\"Return the Tk button widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_button.Button.button","title":"<code>button</code>  <code>property</code>","text":"<p>Return the Tk button widget</p>"},{"location":"reference/#guitk.ttk_button.Button.__init__","title":"<code>__init__(text, key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a Button widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n        **kwargs,\n    )\n\n    self.widget_type = \"ttk.Button\"\n    self.text = text\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.tooltip = tooltip\n    self.padx = padx\n    self.pady = pady\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#browsefilebutton","title":"BrowseFileButton","text":"<p>         Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a file.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseFileButton(Button):\n\"\"\"Button that opens a file dialog to select a file.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        filename_only: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize a BrowseFileButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected filename.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseFileButton\"\n        self._filename = None\n        self._filename_only = filename_only\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def filename(self):\n        return self._filename\n\n    def browse_dialog(self):\n\"\"\"Open a file dialog to select a file\"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._filename = filedialog.askopenfilename(**kwargs_options)\n        if self._filename_only and self._filename:\n            # only want the name, not the path\n            self._filename = pathlib.Path(self._filename).name\n        if self.target_key and self._filename:\n            self.window[self.target_key].value = self._filename\n        event = Event(self, self.window, self.key, EventType.BrowseFile)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseFileButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, filename_only=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseFileButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected filename.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>filename_only</code> <code>bool</code> <p>If True, only the filename is returned. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    filename_only: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize a BrowseFileButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected filename.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseFileButton\"\n    self._filename = None\n    self._filename_only = filename_only\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseFileButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a file</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n\"\"\"Open a file dialog to select a file\"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._filename = filedialog.askopenfilename(**kwargs_options)\n    if self._filename_only and self._filename:\n        # only want the name, not the path\n        self._filename = pathlib.Path(self._filename).name\n    if self.target_key and self._filename:\n        self.window[self.target_key].value = self._filename\n    event = Event(self, self.window, self.key, EventType.BrowseFile)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#browsedirectorybutton","title":"BrowseDirectoryButton","text":"<p>         Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseDirectoryButton(Button):\n\"\"\"Button that opens a file dialog to select a directory.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a BrowseDirectoryButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected directory.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseDirectoryButton\"\n        self._dirname = None\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def directory(self):\n        return self._dirname\n\n    def browse_dialog(self):\n\"\"\"\n        Open a file dialog to select a directory.\n        \"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._dirname = filedialog.askdirectory(**kwargs_options)\n        if self.target_key and self._dirname:\n            self.window[self.target_key].value = self._dirname\n        event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseDirectoryButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseDirectoryButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected directory.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a BrowseDirectoryButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected directory.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseDirectoryButton\"\n    self._dirname = None\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseDirectoryButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n\"\"\"\n    Open a file dialog to select a directory.\n    \"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._dirname = filedialog.askdirectory(**kwargs_options)\n    if self.target_key and self._dirname:\n        self.window[self.target_key].value = self._dirname\n    event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#entry","title":"Entry","text":"<p>         Bases: <code>Widget</code></p> <p>ttk.Entry text entry / input box</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class Entry(Widget):\n\"\"\"ttk.Entry text entry / input box\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize an Entry widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Entry\"\n        default = default or \"\"\n        self._value.set(default)\n        self.key = key or \"Entry\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.hscrollbar = hscrollbar\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        # build arg list for ttk.Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            ttk.Entry,\n            hscrollbar=self.hscrollbar,\n            textvariable=self._value,\n            **kwargs_entry,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n\"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_entry.Entry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.ttk_entry.Entry.__init__","title":"<code>__init__(key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize an Entry widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Entry\"\n    default = default or \"\"\n    self._value.set(default)\n    self.key = key or \"Entry\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.hscrollbar = hscrollbar\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#labelentry","title":"LabelEntry","text":"<p>         Bases: <code>Entry</code></p> <p>Text entry / input box with a label</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class LabelEntry(Entry):\n\"\"\"Text entry / input box with a label\"\"\"\n\n    # TODO: add option to put label above the entry box\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize an Entry widget.\n\n        Args:\n            text (str): Label text.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            default=default,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            hscrollbar=hscrollbar,\n            focus=focus,\n            weightx=weightx,\n            weighty=weighty,\n        )\n        self.widget_type = \"guitk.LabelEntry\"\n        self.text = text\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        # build arg list for Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = _ttkLabelEntry(\n            parent, text=self.text, textvariable=self._value, **kwargs_entry\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n\"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_entry.LabelEntry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.ttk_entry.LabelEntry.__init__","title":"<code>__init__(text, key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Label text.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget will have focus. Defaults to False. Only one widget can have focus.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize an Entry widget.\n\n    Args:\n        text (str): Label text.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        default=default,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        hscrollbar=hscrollbar,\n        focus=focus,\n        weightx=weightx,\n        weighty=weighty,\n    )\n    self.widget_type = \"guitk.LabelEntry\"\n    self.text = text\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#text","title":"Text","text":"<p>         Bases: <code>Widget</code></p> <p>A tk Text box</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Text(Widget):\n\"\"\"A tk Text box\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        vscrollbar: bool = False,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a Text widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"tk.Text\"\n        self.key = key or \"Text\"\n        self.width = width\n        self.height = height\n        self._value = text if text is not None else \"\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.vscrollbar = vscrollbar\n        self.hscrollbar = hscrollbar\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_text = {\n            k: v for k, v in self.kwargs.items() if k in _valid_tk_text_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            tk.Text,\n            vscrollbar=self.vscrollbar,\n            hscrollbar=self.hscrollbar,\n            width=self.width,\n            height=self.height,\n            **kwargs_text,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        self.value = self._value\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget[\"state\"] = \"disabled\"\n\n        return self.widget\n\n    @property\n    def value(self):\n        return self.widget.get(\"1.0\", tk.END).rstrip()\n\n    @value.setter\n    def value(self, text):\n        self.widget.delete(\"1.0\", tk.END)\n        self.widget.insert(\"1.0\", text)\n\n    @property\n    def text(self):\n\"\"\"Return the Tk text widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.tk_text.Text.text","title":"<code>text</code>  <code>property</code>","text":"<p>Return the Tk text widget</p>"},{"location":"reference/#guitk.tk_text.Text.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, vscrollbar=False, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Text widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>False</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    vscrollbar: bool = False,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a Text widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"tk.Text\"\n    self.key = key or \"Text\"\n    self.width = width\n    self.height = height\n    self._value = text if text is not None else \"\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.vscrollbar = vscrollbar\n    self.hscrollbar = hscrollbar\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#output","title":"Output","text":"<p>         Bases: <code>Text</code></p> <p>Text box that redirects stderr and/or stdout to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Output(Text):\n\"\"\"Text box that redirects stderr and/or stdout to the text box.\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        vscrollbar: bool = True,\n        hscrollbar: bool = False,\n        stdout: bool = True,\n        stderr: bool = True,\n        echo: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize an Output widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n            stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n            echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n        \"\"\"\n        super().__init__(\n            text=text,\n            key=key,\n            width=width,\n            height=height,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            vscrollbar=vscrollbar,\n            hscrollbar=hscrollbar,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n            **kwargs,\n        )\n\n        self.kwargs = kwargs\n        self._echo = echo\n        self._stdout = stdout\n        self._stderr = stderr\n\n        # stores state for stdout and stderr redirection\n        self._redirect = []\n        self._redirect_id = {}\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        self.widget = super()._create_widget(parent, window, row, col)\n\n        # Unbind &lt;KeyRelease&gt; since this isn't for user input\n        self.widget.unbind(\"&lt;KeyRelease&gt;\")\n\n        if self.events:\n            event = Event(self, window, self.key, EventType.OutputWrite)\n            self.window.root.bind_all(\n                EventType.OutputWrite.value, window._make_callback(event)\n            )\n\n        self._configure_redirect()\n        self.enable_redirect()\n\n        return self.widget\n\n    def _configure_redirect(self):\n\"\"\"Configure stdout and stderr redirection.\"\"\"\n        if self._stdout:\n            self._redirect.append(StdOutRedirect())\n        if self._stderr:\n            self._redirect.append(StdErrRedirect())\n        for r in self._redirect:\n            r.echo = self._echo\n            self._redirect_id[r] = r.register(self._write)\n\n    def _write(self, line):\n        self.text.insert(tk.END, line)\n        self.text.yview(tk.END)\n        self.window.root.event_generate(EventType.OutputWrite.value)\n\n    @property\n    def echo(self):\n\"\"\"Return True if stdout and stderr are echoed to the console.\"\"\"\n        return self._echo\n\n    @echo.setter\n    def echo(self, echo):\n\"\"\"Set whether stdout and stderr are echoed to the console.\"\"\"\n        self._echo = echo\n        for r in self._redirect:\n            r.echo = echo\n\n    def disable_redirect(self):\n\"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.disable_redirect()\n\n    def enable_redirect(self):\n\"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.enable_redirect()\n\n    def __del__(self):\n        for r, id_ in self._redirect_id.items():\n            r.deregister(id_)\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.echo","title":"<code>echo</code>  <code>writable</code> <code>property</code>","text":"<p>Return True if stdout and stderr are echoed to the console.</p>"},{"location":"reference/#guitk.tk_text.Output.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, vscrollbar=True, hscrollbar=False, stdout=True, stderr=True, echo=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Output widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> required <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>True</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>stdout</code> <code>bool</code> <p>Redirect stdout to the text box. Defaults to True.</p> <code>True</code> <code>stderr</code> <code>bool</code> <p>Redirect stderr to the text box. Defaults to True.</p> <code>True</code> <code>echo</code> <code>bool</code> <p>Echo stdout and stderr to the console. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    vscrollbar: bool = True,\n    hscrollbar: bool = False,\n    stdout: bool = True,\n    stderr: bool = True,\n    echo: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize an Output widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n        stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n        echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n    \"\"\"\n    super().__init__(\n        text=text,\n        key=key,\n        width=width,\n        height=height,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        vscrollbar=vscrollbar,\n        hscrollbar=hscrollbar,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n        **kwargs,\n    )\n\n    self.kwargs = kwargs\n    self._echo = echo\n    self._stdout = stdout\n    self._stderr = stderr\n\n    # stores state for stdout and stderr redirection\n    self._redirect = []\n    self._redirect_id = {}\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.disable_redirect","title":"<code>disable_redirect()</code>","text":"<p>Disable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def disable_redirect(self):\n\"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.disable_redirect()\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.enable_redirect","title":"<code>enable_redirect()</code>","text":"<p>Enable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def enable_redirect(self):\n\"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.enable_redirect()\n</code></pre>"}]}