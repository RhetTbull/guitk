{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MacNotesApp","text":"<p>Python GUI Toolkit for Tk (guitk): simplify the layout and construction of tkinter graphical user interfaces in python.</p> <p>For full documentation visit GUITk.</p>"},{"location":"#installation","title":"Installation","text":"<p>pip install guitk</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#window","title":"Window","text":"<p>         Bases: <code>_Layout</code>, <code>_WindowBaseClass</code></p> <p>Basic Window class from which all windows are derived</p> Notes <p>Classes which inherit from window should implement handle_event, setup, and teardown as needed</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>class Window(_Layout, _WindowBaseClass):\n\"\"\"Basic Window class from which all windows are derived\n\n    Notes:\n        Classes which inherit from window should implement handle_event, setup, and teardown as needed\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: tk.Tk | None = None,\n        title: str | None = None,\n        padx: int | None = None,\n        pady: int | None = None,\n        topmost: bool | None = None,\n        autoframe: bool = True,\n        theme: str | None = None,\n        tooltip: TooltipType | None = None,\n        modal: bool | None = None,\n    ):\n        # call _config then subclass's config to initialize\n        # layout, title, menu, etc.\n\n        self._config()\n        self.config()\n\n        # override any layout defaults from constructor\n        self.title = title if title is not None else self.title\n        self.padx = padx if padx is not None else self.padx\n        self.pady = pady if pady is not None else self.pady\n        self.theme = theme if theme is not None else self.theme\n        self.tooltip = tooltip if tooltip is not None else self.tooltip\n        self.modal = modal if modal is not None else self.modal\n\n        self._id = id(self)\n        self._tk = _TKRoot()\n        self._parent = parent or self._tk.root\n        self._topmost = topmost\n\n        self.window = tk.Toplevel(self._parent)\n        self.window.title(self.title)\n        self._widgets = []\n        self._widget_by_key = {}\n\n        self._timer_events = {}\n\"\"\" timer events that have been set by bind_timer_event, stores most recent after() id for event\"\"\"\n\n        self._timer_events_cancelled = {}\n\"\"\" timer events that have been set by bind_timer_event but then cancelled \"\"\"\n\n        self._return_value = None\n\"\"\" value returned from run() if set in quit() \"\"\"\n\n        self._root_menu = None\n\"\"\" will hold root tk.Menu widget\"\"\"\n\n        self._radiobuttons = {}\n\"\"\" will hold group name/variable for radio buttons in the window \"\"\"\n\n        self._mainframe = ttk.Frame(self.window, padding=\"3 3 12 12\")\n        self._mainframe.grid(column=0, row=0, sticky=(tk.N, tk.W, tk.E, tk.S))\n        self.window.columnconfigure(0, weight=1)\n        self.window.rowconfigure(0, weight=1)\n\n        self._tk.register(self)\n        self.window.protocol(\n            \"WM_DELETE_WINDOW\",\n            self._make_callback(Event(self, self, EventType.Quit, EventType.Quit)),\n        )\n\n        if not self.layout:\n            self.layout = [\n                [\n                    Label(\n                        \"Looks like you forgot to include a layout in your class definition\"\n                    )\n                ]\n            ]\n\n        self._commands = []\n        self._layout(self._mainframe, self, autoframe=autoframe)\n\n        # apply theme if necessary\n        if self.theme is not None:\n            self._tk.theme = self.theme\n\n        # apply padding, widget padding takes precedent over window\n        for widget in self._widgets:\n            padx = widget.padx or self.padx\n            pady = widget.pady or self.pady\n            widget.widget.grid_configure(padx=padx, pady=pady)\n\n        if self.menu:\n            self._build_menu()\n\n        if self._topmost or self.modal:\n            self.window.attributes(\"-topmost\", 1)\n\n        if self.modal:\n            windowingsystem = self.root.call(\"tk\", \"windowingsystem\")\n            if windowingsystem == \"aqua\":\n                try:\n                    self.root.call(\n                        \"::tk::unsupported::MacWindowStyle\",\n                        \"style\",\n                        self._w,\n                        \"moveableModal\",\n                        \"\",\n                    )\n                except:\n                    pass\n\n            if self._parent is not None and self._parent.winfo_viewable():\n                self.window.transient(self._parent)\n            self.window.wait_visibility()\n            self.window.grab_set()\n\n        # TODO: add geometry code to ensure window appears in good spot relative to parent\n\n        self.events = True\n\n        self.setup()\n\n        if self.modal:\n            self.window.wait_window()\n\n        self._bind_timer_event(\n            100, EventType.WindowFinishedLoading.value, EventType.WindowFinishedLoading\n        )\n\n    def _config(self):\n        self.title = \"My Window\"\n\"\"\"Title to display in the window's title bar \"\"\"\n\n        # self.layout = [\n        #     [\n        #         Label(\n        #             \"Looks like you forgot to add self.layout to your config() method.\"\n        #         )\n        #     ],\n        #     [Button(\"Quit\")],\n        # ]\n        self.layout = []\n\"\"\"Every class that inherits from Window must define it's own layout \"\"\"\n\n        self.menu = {}\n\"\"\" Optionally provide a menu \"\"\"\n\n        self.padx = 5\n        self.pady = 5\n\"\"\"Default padding around widgets \"\"\"\n\n        self.theme = None\n\"\"\"The ttk theme to use, if None, uses ttk default\"\"\"\n\n        self.tooltip = None\n\"\"\" A callable which returns the tooltip text for a given key or a str \"\"\"\n\n        self.modal = False\n\"\"\" Set to True to create modal window \"\"\"\n\n    def config(self):\n        pass\n\n    def handle_event(self, event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n        if event.event_type == EventType.Quit:\n            self.quit(self._return_value)\n\n    def setup(self):\n\"\"\"Perform any needed setup for the window.\n        Gets called immediately after __init__\n        \"\"\"\n        pass\n\n    def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n        Gets called immediately before the window is destroyed\n        \"\"\"\n        pass\n\n    def quit(self, return_value=None):\n\"\"\"Close the window\"\"\"\n        self._return_value = return_value\n        self._destroy()\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        self._title = value\n\n    def bind_command(self, key=None, event_type=None, command=None):\n        if not any([key, event_type]):\n            raise ValueError(\"At least one of key, event_type must be specified\")\n        self._bind_command(\n            EventCommand(widget=None, key=key, event_type=event_type, command=command)\n        )\n\n    def _bind_command(self, event_command: EventCommand):\n        self._commands.append(event_command)\n\n    def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n        repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n        if command:\n            self.bind_command(\n                key=event_name, event_type=EventType.VirtualEvent, command=command\n            )\n        return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n\n    def _bind_timer_event(self, delay, event_name, event_type, repeat=False):\n        # create a unique name for the timer\n        timer_id = f\"{event_name}_{time.time_ns()}\"\n\n        # callback that generates event and respawns the timer if repeat=True\n        # when cancelling with cancel_timer_event, sometimes the call to after_cancel doesn't apparently work so check\n        # if timer_id is in _timer_events_cancelled before respawning\n        def _generate_event():\n            self.root.event_generate(event_name)\n            if repeat and timer_id not in self._timer_events_cancelled:\n                self._timer_events[timer_id] = self._tk.root.after(\n                    delay, _generate_event\n                )\n\n        event = Event(self, self, event_name, event_type)\n        self.root.bind(event_name, self._make_callback(event))\n        self._timer_events[timer_id] = self._tk.root.after(delay, _generate_event)\n        return timer_id\n\n    def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n        try:\n            after_id = self._timer_events[timer_id]\n            self.root.after_cancel(after_id)\n            self._timer_events.pop(timer_id)\n            self._timer_events_cancelled[timer_id] = after_id\n        except KeyError:\n            raise ValueError(f\"Timer event {timer_id} not found\")\n        except Exception as e:\n            raise e\n\n    def run(self):\n        self._tk.run_mainloop()\n        return self._return_value\n\n    @property\n    def root(self):\n\"\"\"Return Tk root instance\"\"\"\n        return self._tk.root\n\n    def children(self):\n\"\"\"Return child windows\"\"\"\n        return self._tk.get_children(self)\n\n    def _add_menus(self, menu: Menu, menu_items, path=None):\n        path = f\"MENU:{menu._label}\" if path is None else path\n        for m in menu_items:\n            if type(m) == dict:\n                # submenu\n                for subm in m:\n                    subm._create_widget(menu._menu, self)\n                    subpath = f\"{path}|{subm._label}\"\n                    self._add_menus(subm, m[subm], subpath)\n            elif isinstance(m, Command):\n                command_path = f\"{path}|{m._label}\"\n                m._create_widget(menu._menu, self, command_path)\n\n    def _build_menu(self):\n        if type(self.menu) != dict:\n            raise ValueError(\"self.menu must be a dict\")\n\n        if self._root_menu is None:\n            # create the root menu\n            self.root.option_add(\"*tearOff\", tk.FALSE)\n            self._root_menu = tk.Menu(self.root)\n            self.window[\"menu\"] = self._root_menu\n\n        for m in self.menu:\n            if not isinstance(m, Menu):\n                raise ValueError(\"self.menu keys must be Menu objects\")\n            m._create_widget(self._root_menu, self)\n            self._add_menus(m, self.menu[m])\n\n    def _destroy(self):\n        # kill any child windows\n        for child in self.children():\n            event = Event(child, child.window, EventType.Quit, EventType.Quit)\n            child.handle_event(event)\n            with contextlib.suppress(Exception):\n                child._destroy()\n\n        # disable event processing in _handle_event\n        self.events = False\n\n        # disable any stdout/stderr redirection and event handling\n        for widget in self._widgets:\n            widget.events = False\n\n            if \"guitk.widgets.tk_text.Output\" in str(type(widget)):\n                widget.disable_redirect()\n\n        if self.modal:\n            self.window.grab_release()\n\n        # cancel any timer events\n        for timer_id in self._timer_events:\n            with contextlib.suppress(Exception):\n                after_id = self._timer_events[timer_id]\n                self._tk.root.after_cancel(after_id)\n        self.teardown()\n        self._parent.focus_set()\n        self.window.destroy()\n        self._tk.deregister(self)\n\n    def _make_callback(self, event):\n        def _callback(*arg):\n            if arg:\n                event.event = arg[0]\n            self._handle_event(event)\n\n        return _callback\n\n    def _handle_event(self, event):\n        # only handle events if widget has events=True; Window objects always get events\n        if isinstance(event.widget, (Widget, Window)) and not event.widget.events:\n            return\n\n        # filter events for this window\n        if event.id == self._id:\n            # handle custom commands\n            self._handle_commands(event)\n\n            self.handle_event(event)\n\n            # if deleting the window, call _destroy after handle_event has had a chance to handle it\n            if event.event_type == EventType.Quit:\n                self._destroy()\n\n    def _handle_commands(self, event):\n        for command in self._commands:\n            if (\n                (command.widget is None or command.widget == event.widget)\n                and (command.key is None or command.key == event.key)\n                and (\n                    command.event_type is None or command.event_type == event.event_type\n                )\n            ):\n                command.command()\n\n    def __getitem__(self, key) -&gt; \"Widget\":\n        try:\n            return self._widget_by_key[key]\n        except KeyError:\n            raise KeyError(f\"Invalid key: no widget with key {key}\")\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return Tk root instance</p>"},{"location":"reference/#guitk.widgets.window.Window.bind_timer_event","title":"<code>bind_timer_event(delay, event_name, repeat=False, command=None)</code>","text":"<p>Create a new virtual event <code>event_name</code> that fires after <code>delay</code> ms, repeats every <code>delay</code> ms if repeat=True, otherwise fires once</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n    repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n    if command:\n        self.bind_command(\n            key=event_name, event_type=EventType.VirtualEvent, command=command\n        )\n    return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.cancel_timer_event","title":"<code>cancel_timer_event(timer_id)</code>","text":"<p>Cancel a timer event created with bind_timer_event</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n    try:\n        after_id = self._timer_events[timer_id]\n        self.root.after_cancel(after_id)\n        self._timer_events.pop(timer_id)\n        self._timer_events_cancelled[timer_id] = after_id\n    except KeyError:\n        raise ValueError(f\"Timer event {timer_id} not found\")\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.children","title":"<code>children()</code>","text":"<p>Return child windows</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def children(self):\n\"\"\"Return child windows\"\"\"\n    return self._tk.get_children(self)\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.handle_event","title":"<code>handle_event(event)</code>","text":"<p>Handle event objects, inheriting classes should implement handle_event</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def handle_event(self, event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n    if event.event_type == EventType.Quit:\n        self.quit(self._return_value)\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.quit","title":"<code>quit(return_value=None)</code>","text":"<p>Close the window</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def quit(self, return_value=None):\n\"\"\"Close the window\"\"\"\n    self._return_value = return_value\n    self._destroy()\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.setup","title":"<code>setup()</code>","text":"<p>Perform any needed setup for the window. Gets called immediately after init</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def setup(self):\n\"\"\"Perform any needed setup for the window.\n    Gets called immediately after __init__\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#guitk.widgets.window.Window.teardown","title":"<code>teardown()</code>","text":"<p>Perform any cleanup before the window closes. Gets called immediately before the window is destroyed</p> Source code in <code>guitk/widgets/window.py</code> <pre><code>def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n    Gets called immediately before the window is destroyed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#button","title":"Button","text":"<p>         Bases: <code>Widget</code></p> <p>Basic button</p> Source code in <code>guitk/widgets/ttk_button.py</code> <pre><code>class Button(Widget):\n\"\"\"Basic button\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        key: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: int | None = None,\n        pady: int | None = None,\n        width: int | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        anchor: str | None = None,\n        takefocus: bool | None = None,\n        command: CommandType | None = None,\n        **kwargs,\n    ):\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            width=width,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            anchor=anchor,\n            takefocus=takefocus,\n            command=command,\n            **kwargs,\n        )\n\n        self.widget_type = \"ttk.Button\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tooltip = tooltip\n        self.width = width\n        self.kwargs = kwargs\n\n    @property\n    def value(self) -&gt; str:\n        return self.widget[\"text\"]\n\n    @value.setter\n    def value(self, text: str):\n        self.widget[\"text\"] = text\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        self.window = window\n        self._parent = parent\n        event = Event(self, window, self.key, EventType.ButtonPress)\n\n        # build arg list for Button()\n        kwargs = {}\n        for kw in [\"text\", \"anchor\", \"width\", \"takefocus\"]:\n            val = getattr(self, f\"{kw}\")\n            if val is not None:\n                kwargs[kw] = val\n        kwargs |= self.kwargs\n\n        self.widget = ttk.Button(parent, command=window._make_callback(event), **kwargs)\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ButtonPress,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def button(self):\n\"\"\"Return the Tk button widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.widgets.ttk_button.Button.button","title":"<code>button</code>  <code>property</code>","text":"<p>Return the Tk button widget</p>"}]}