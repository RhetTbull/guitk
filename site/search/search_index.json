{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GUITk's documentation!","text":"<p>GUITk is a declarative framework for building nice-looking, cross-platform GUIs with tkinter inspired by SwiftUI.</p> <p>GUITk allows you to build complete GUI applications with a few lines of code. GUITk makes it easy to layout your GUI elements and respond to events using a declarative syntax. Because GUITk is built on top of tkinter, you can access the underlying tkinter API if you need to but for many use cases, you can build your GUI without needing to know much about tkinter.</p> <p>GUITk apps are built by subclasses the <code>guitk.Window</code> class. Your GUI elements are layed out using a <code>guitk.HLayout</code> (horizontal layout) or <code>guitk.VLayout</code> (vertical layout) object which takes care of placing all widgets in the window using a declarative syntax. This is much simpler than using the underlying tkinter grid manager or pack geometry managers.</p> <p>GUITk is in alpha stage but is in constant development so check back frequently if this interests you or open an issue to start a conversation about what pain points this project could help you solve!</p> <p>For full documentation visit GUITk.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install guitk</code></p>"},{"location":"#source-code","title":"Source Code","text":"<p>GUITk on GitHub</p>"},{"location":"#license","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2020 Rhet Turnbull, All rights reserved.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#window","title":"Window","text":"<p>         Bases: <code>_LayoutMixin</code>, <code>_WindowBaseClass</code></p> <p>Basic Window class from which all windows are derived</p> Notes <p>Classes which inherit from window should implement handle_event, setup, and teardown as needed</p> Source code in <code>guitk/window.py</code> <pre><code>class Window(_LayoutMixin, _WindowBaseClass):\n\"\"\"Basic Window class from which all windows are derived\n\n    Notes:\n        Classes which inherit from window should implement handle_event, setup, and teardown as needed\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: tk.Tk | None = None,\n        title: str | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        topmost: bool | None = None,\n        autoframe: bool = False,\n        theme: str | None = None,\n        tooltip: TooltipType | None = None,\n        modal: bool | None = None,\n        size: SizeType = None,\n    ):\n        # call _config then subclass's config to initialize\n        # layout, title, menu, etc.\n\n        self.autoframe = autoframe\n\n        self._config()\n        self.config()\n\n        # override any layout defaults from constructor\n        self.title: str | None = title if title is not None else self.title\n        self.padx: int | None = padx if padx is not None else self.padx\n        self.pady: int | None = pady if pady is not None else self.pady\n        self.theme: str | None = theme if theme is not None else self.theme\n        self.tooltip: TooltipType | None = (\n            tooltip if tooltip is not None else self.tooltip\n        )\n        self.modal: bool | None = modal if modal is not None else self.modal\n        self.size: SizeType = size if size is not None else self.size\n\n        self._id: int = id(self)\n        self._tk: _TKRoot = _TKRoot()\n        self._parent = parent or self._tk.root\n        self._topmost = topmost\n\n        self.window: tk.TopLevel = tk.Toplevel(self._parent)\n        self.window.title(self.title)\n        self._widgets = []\n        self._widget_by_key = {}\n\n        self._timer_events = {}\n\"\"\" timer events that have been set by bind_timer_event, stores most recent after() id for event\"\"\"\n\n        self._timer_events_cancelled = {}\n\"\"\" timer events that have been set by bind_timer_event but then cancelled \"\"\"\n\n        self._return_value = None\n\"\"\" value returned from run() if set in quit() \"\"\"\n\n        self._root_menu = None\n\"\"\" will hold root tk.Menu widget\"\"\"\n\n        self._radiobuttons = {}\n\"\"\" will hold group name/variable for radio buttons in the window \"\"\"\n\n        self._destroyed = False\n\"\"\" set to True when window is destroyed \"\"\"\n\n        self._mainframe = ttk.Frame(self.window, padding=\"3 3 12 12\")\n        self._mainframe.grid(column=0, row=0, sticky=\"nsew\")\n        self.window.columnconfigure(0, weight=1)\n        self.window.rowconfigure(0, weight=1)\n\n        self._tk.register(self)\n        self.window.protocol(\n            \"WM_DELETE_WINDOW\",\n            self._make_callback(Event(self, self, EventType.Quit, EventType.Quit)),\n        )\n\n        if not self.layout:\n            self.layout = [\n                [\n                    Label(\n                        \"Looks like you forgot to include a layout in your class definition\"\n                    )\n                ]\n            ]\n\n        self._commands = []\n\n        self._layout(self._mainframe, self)\n\n        # apply theme if necessary\n        if self.theme is not None:\n            self._tk.theme = self.theme\n\n        self._grid_configure_widgets()\n\n        if self.menu:\n            self._build_menu()\n\n        if self._topmost or self.modal:\n            self.window.attributes(\"-topmost\", 1)\n\n        if self.modal:\n            windowingsystem = self.root.call(\"tk\", \"windowingsystem\")\n            if windowingsystem == \"aqua\":\n                with contextlib.suppress(Exception):\n                    self.root.call(\n                        \"::tk::unsupported::MacWindowStyle\",\n                        \"style\",\n                        self._w,\n                        \"moveableModal\",\n                        \"\",\n                    )\n            if self._parent is not None and self._parent.winfo_viewable():\n                self.window.transient(self._parent)\n            self.window.wait_visibility()\n            self.window.grab_set()\n\n        if self.size is not None:\n            size = (\n                self.size\n                if isinstance(self.size, str)\n                else f\"{self.size[0]}x{self.size[1]}\"\n            )\n            self.window.geometry(size)\n\n        # TODO: add geometry code to ensure window appears in good spot relative to parent\n\n        # setup event handling\n        self.events = True\n        self._bind_timer_event(\n            100, EventType.WindowFinishedLoading.value, EventType.WindowFinishedLoading\n        )\n        self._bind_event_handlers()\n        self._create_setup_teardown_events()\n\n        self.setup()\n        self.root.event_generate(EventType.Setup.value)\n\n        if self.modal:\n            self.window.wait_window()\n\n    def _grid_configure_widgets(self):\n\"\"\"Apply padding to all widgets in the window\"\"\"\n        # apply padding, widget padding takes precedent over window\n        for widget in self._widgets:\n            padx = widget.padx if widget.padx is not None else self.padx\n            pady = widget.pady if widget.pady is not None else self.pady\n            widget.widget.grid_configure(padx=padx, pady=pady)\n\n    def _config(self):\n        self.title = \"My Window\"\n\"\"\"Title to display in the window's title bar \"\"\"\n\n        self.layout = []\n\"\"\"Every class that inherits from Window must define it's own layout \"\"\"\n\n        self.menu = {}\n\"\"\" Optionally provide a menu \"\"\"\n\n        self.padx = DEFAULT_PADX\n        self.pady = DEFAULT_PADY\n\"\"\"Default padding around widgets \"\"\"\n\n        self.theme = None\n\"\"\"The ttk theme to use, if None, uses ttk default\"\"\"\n\n        self.tooltip = None\n\"\"\" A callable which returns the tooltip text for a given key or a str \"\"\"\n\n        self.modal = False\n\"\"\" Set to True to create modal window \"\"\"\n\n        self.size = None\n\"\"\" Set to a tuple of (width, height) to set the window size \"\"\"\n\n        push_parent(self)\n\n    def config(self):\n        pass\n\n    def handle_event(self, event: Event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n        ...\n        # if event.event_type == EventType.Quit:\n        # self.quit(self._return_value)\n\n    def setup(self):\n\"\"\"Perform any needed setup for the window.\n        Gets called immediately after __init__\n        \"\"\"\n        pass\n\n    def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n        Gets called immediately before the window is destroyed\n        \"\"\"\n        pass\n\n    @debug_watch\n    def quit(self, return_value: Any = None):\n\"\"\"Called when closing the window\"\"\"\n        # set return value which is returned by run()\n        self._return_value = return_value\n        self._destroy()\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        self._title = value\n\n    @property\n    def geometry(self):\n        return self.size\n\n    @geometry.setter\n    def geometry(self, value):\n        self.size = value\n\n    def bind_command(self, key=None, event_type=None, command=None):\n        if not any([key, event_type]):\n            raise ValueError(\"At least one of key, event_type must be specified\")\n        self._bind_command(\n            EventCommand(widget=None, key=key, event_type=event_type, command=command)\n        )\n\n    def _bind_command(self, event_command: EventCommand):\n        self._commands.append(event_command)\n\n    def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n        repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n        if command:\n            self.bind_command(\n                key=event_name, event_type=EventType.VirtualEvent, command=command\n            )\n        return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n\n    def _bind_timer_event(self, delay, event_name, event_type, repeat=False):\n        # create a unique name for the timer\n        timer_id = f\"{event_name}_{time.time_ns()}\"\n\n        # callback that generates event and respawns the timer if repeat=True\n        # when cancelling with cancel_timer_event, sometimes the call to after_cancel doesn't apparently work so check\n        # if timer_id is in _timer_events_cancelled before respawning\n        def _generate_event():\n            self.root.event_generate(event_name)\n            if repeat and timer_id not in self._timer_events_cancelled:\n                self._timer_events[timer_id] = self._tk.root.after(\n                    delay, _generate_event\n                )\n\n        event = Event(self, self, event_name, event_type)\n        self.root.bind(event_name, self._make_callback(event))\n        self._timer_events[timer_id] = self._tk.root.after(delay, _generate_event)\n        return timer_id\n\n    def _create_setup_teardown_events(self):\n\"\"\"Create the setup and teardown events\"\"\"\n        setup_event = Event(self, self, EventType.Setup.value, EventType.Setup)\n        self.root.bind(EventType.Setup.value, self._make_callback(setup_event))\n\n        teardown_event = Event(self, self, EventType.Teardown.value, EventType.Teardown)\n        self.root.bind(EventType.Teardown.value, self._make_callback(teardown_event))\n\n    def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n        try:\n            after_id = self._timer_events[timer_id]\n            self.root.after_cancel(after_id)\n            self._timer_events.pop(timer_id)\n            self._timer_events_cancelled[timer_id] = after_id\n        except KeyError as e:\n            raise ValueError(f\"Timer event {timer_id} not found\") from e\n        except Exception as e:\n            raise e\n\n    def _bind_event_handlers(self):\n\"\"\"Bind any event handlers decorated with @on\"\"\"\n        for method in self.__class__.__dict__.values():\n            if hasattr(method, \"_guitk_event_handlers\"):\n                for key, event_type in getattr(method, \"_guitk_event_handlers\"):\n                    self.bind_command(key=key, event_type=event_type, command=method)\n\n    def add_widget(self, widget: BaseWidget, row: int, col: int):\n\"\"\"Add a widget to the window's mainframe\"\"\"\n        widget._create_widget(self._mainframe, self, row, col)\n        self._widgets.append(widget)\n        self._widget_by_key[widget.key] = widget\n        self._grid_configure_widgets()\n\n    def remove(self, key_or_widget: Hashable | BaseWidget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n        for idx, widget in enumerate(self._widgets):\n            debug(f\"{idx=} {widget=} {key_or_widget=}\")\n            if widget == key_or_widget or widget.key == key_or_widget:\n                widget = self._widgets[idx]\n                if widget.parent == self:\n                    self._remove(widget)\n                else:\n                    widget.parent.remove(widget)\n                return\n        raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n\n    def _remove(self, widget: BaseWidget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n        widget.widget.grid_forget()\n        widget.widget.destroy()\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n        self.window.update_idletasks()\n\n    def _insert_widget_row_col(self, widget: BaseWidget, row: int, col: int):\n\"\"\"Insert a widget into the window's mainframe after the container has been created\n            Intended for use at run-time only when widgets need to be added dynamically\n\n        Args:\n            widget: (Widget) the widget to add\n            row: (int) the row to insert the widget into\n            col: (int) the column to insert the widget into\n\n        Note:\n            This method is included in Window so that Widget.replace() works properly for\n            widgets added directly to a layout. It does not expand the layout like the similar\n            method in _Container.\n        \"\"\"\n        # TODO: fix this so it actually inserts instead of replaces\n        self.add_widget(widget, row, col)\n\n    def run(self):\n        self._tk.run_mainloop()\n        return self._return_value\n\n    @property\n    def root(self):\n\"\"\"Return Tk root instance\"\"\"\n        return self._tk.root\n\n    @property\n    def widgets(self) -&gt; list[BaseWidget]:\n\"\"\" \"Return list of all widgets belonging to the window\"\"\"\n        return self._widgets\n\n    def children(self):\n\"\"\"Return child windows\"\"\"\n        return self._tk.get_children(self)\n\n    def get(self, key: Hashable) -&gt; BaseWidget:\n\"\"\"Get widget with key or raise KeyError if not found\"\"\"\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Widget with key {key} not found\") from e\n\n    def _add_widget(self, widget: BaseWidget):\n\"\"\"Dummy method to allow widgets to be added with VLayout()/HLayout()\"\"\"\n        pass\n\n    def _forget_widget(self, widget: BaseWidget):\n\"\"\"Remove widget from the window's bookkeeping but don't destroy it\"\"\"\n        self._widget_by_key.pop(widget.key, None)\n        self._widgets.remove(widget)\n\n    def _add_menus(self, menu: Menu, menu_items, path=None):\n        path = f\"MENU:{menu._label}\" if path is None else path\n        for m in menu_items:\n            if type(m) == dict:\n                # submenu\n                for subm in m:\n                    subm._create_widget(menu._menu, self)\n                    subpath = f\"{path}|{subm._label}\"\n                    self._add_menus(subm, m[subm], subpath)\n            elif isinstance(m, Command):\n                command_path = f\"{path}|{m._label}\"\n                m._create_widget(menu._menu, self, command_path)\n\n    def _build_menu(self):\n        if type(self.menu) != dict:\n            raise ValueError(\"self.menu must be a dict\")\n\n        if self._root_menu is None:\n            # create the root menu\n            self.root.option_add(\"*tearOff\", tk.FALSE)\n            self._root_menu = tk.Menu(self.root)\n            self.window[\"menu\"] = self._root_menu\n\n        for m in self.menu:\n            if not isinstance(m, Menu):\n                raise ValueError(\"self.menu keys must be Menu objects\")\n            m._create_widget(self._root_menu, self)\n            self._add_menus(m, self.menu[m])\n\n    @debug_watch\n    def _destroy(self):\n\"\"\"Destroy the window and all child windows and perform cleanup\"\"\"\n        if self._destroyed:\n            # HACK: avoid multiple calls to _destroy which can occur if\n            # the user handles the Quit event themselves\n            # TODO: find a better way to handle this\n            return\n\n        # call teardown to perform any cleanup\n        self.teardown()\n\n        # generate a Teardown event\n        self.root.event_generate(EventType.Teardown.value)\n\n        # kill any child windows\n        for child in self.children():\n            event = Event(child, child.window, EventType.Quit, EventType.Quit)\n            child.handle_event(event)\n            with contextlib.suppress(Exception):\n                child._destroy()\n\n        # disable event processing in _handle_event\n        self.events = False\n\n        # disable any stdout/stderr redirection and event handling\n        for widget in self._widgets:\n            widget.events = False\n\n            if \"guitk.widgets.tk_text.Output\" in str(type(widget)):\n                widget.disable_redirect()\n\n        if self.modal:\n            self.window.grab_release()\n\n        # cancel any timer events\n        for timer_id in self._timer_events:\n            with contextlib.suppress(Exception):\n                after_id = self._timer_events[timer_id]\n                self._tk.root.after_cancel(after_id)\n        self._parent.focus_set()\n        self.window.destroy()\n        self._tk.deregister(self)\n        self._destroyed = True\n\n    def _make_callback(self, event):\n        def _callback(*arg):\n            if arg:\n                event.event = arg[0]\n            self._handle_event(event)\n\n        return _callback\n\n    @debug_watch\n    def _handle_event(self, event: Event):\n\"\"\"Handle events for this window\"\"\"\n        # only handle events if widget has events=True; Window objects always get events\n        if isinstance(event.widget, (BaseWidget, Window)) and not event.widget.events:\n            return\n\n        # filter events for this window\n        if event.id == self._id:\n            # handle custom commands\n            self._handle_commands(event)\n\n            self.handle_event(event)\n\n            # if deleting the window, call _destroy after handle_event has had a chance to handle it\n            if event.event_type == EventType.Quit:\n                self._destroy()\n\n    @debug_watch\n    def _handle_commands(self, event):\n\"\"\"Handle commands bound to widgets in the window\"\"\"\n        for command in self._commands:\n            if (\n                (command.widget is None or command.widget == event.widget)\n                and (command.key is None or command.key == event.key)\n                and (\n                    command.event_type is None or command.event_type == event.event_type\n                )\n            ) or command.event_type == EventType.Any:\n                if hasattr(command.command, \"_guitk_event_handlers\"):\n                    # command was decorated with @on, so it's a method of this class\n                    if len(inspect.signature(command.command).parameters) == 2:\n                        # command has a second argument, assume it's the event\n                        command.command(self, event)\n                    else:\n                        command.command(self)\n                else:\n                    command.command()\n\n    def __getitem__(self, key) -&gt; BaseWidget:\n        try:\n            return self._widget_by_key[key]\n        except KeyError as e:\n            raise KeyError(f\"Invalid key: no widget with key {key}\") from e\n</code></pre>"},{"location":"reference/#guitk.window.Window.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return Tk root instance</p>"},{"location":"reference/#guitk.window.Window.widgets","title":"<code>widgets: list[BaseWidget]</code>  <code>property</code>","text":"<p>\"Return list of all widgets belonging to the window</p>"},{"location":"reference/#guitk.window.Window.add_widget","title":"<code>add_widget(widget, row, col)</code>","text":"<p>Add a widget to the window's mainframe</p> Source code in <code>guitk/window.py</code> <pre><code>def add_widget(self, widget: BaseWidget, row: int, col: int):\n\"\"\"Add a widget to the window's mainframe\"\"\"\n    widget._create_widget(self._mainframe, self, row, col)\n    self._widgets.append(widget)\n    self._widget_by_key[widget.key] = widget\n    self._grid_configure_widgets()\n</code></pre>"},{"location":"reference/#guitk.window.Window.bind_timer_event","title":"<code>bind_timer_event(delay, event_name, repeat=False, command=None)</code>","text":"<p>Create a new virtual event <code>event_name</code> that fires after <code>delay</code> ms, repeats every <code>delay</code> ms if repeat=True, otherwise fires once</p> Source code in <code>guitk/window.py</code> <pre><code>def bind_timer_event(self, delay, event_name, repeat=False, command=None):\n\"\"\"Create a new virtual event `event_name` that fires after `delay` ms,\n    repeats every `delay` ms if repeat=True, otherwise fires once\"\"\"\n    if command:\n        self.bind_command(\n            key=event_name, event_type=EventType.VirtualEvent, command=command\n        )\n    return self._bind_timer_event(delay, event_name, EventType.VirtualEvent, repeat)\n</code></pre>"},{"location":"reference/#guitk.window.Window.cancel_timer_event","title":"<code>cancel_timer_event(timer_id)</code>","text":"<p>Cancel a timer event created with bind_timer_event</p> Source code in <code>guitk/window.py</code> <pre><code>def cancel_timer_event(self, timer_id):\n\"\"\"Cancel a timer event created with bind_timer_event\"\"\"\n    try:\n        after_id = self._timer_events[timer_id]\n        self.root.after_cancel(after_id)\n        self._timer_events.pop(timer_id)\n        self._timer_events_cancelled[timer_id] = after_id\n    except KeyError as e:\n        raise ValueError(f\"Timer event {timer_id} not found\") from e\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"reference/#guitk.window.Window.children","title":"<code>children()</code>","text":"<p>Return child windows</p> Source code in <code>guitk/window.py</code> <pre><code>def children(self):\n\"\"\"Return child windows\"\"\"\n    return self._tk.get_children(self)\n</code></pre>"},{"location":"reference/#guitk.window.Window.get","title":"<code>get(key)</code>","text":"<p>Get widget with key or raise KeyError if not found</p> Source code in <code>guitk/window.py</code> <pre><code>def get(self, key: Hashable) -&gt; BaseWidget:\n\"\"\"Get widget with key or raise KeyError if not found\"\"\"\n    try:\n        return self._widget_by_key[key]\n    except KeyError as e:\n        raise KeyError(f\"Widget with key {key} not found\") from e\n</code></pre>"},{"location":"reference/#guitk.window.Window.handle_event","title":"<code>handle_event(event)</code>","text":"<p>Handle event objects, inheriting classes should implement handle_event</p> Source code in <code>guitk/window.py</code> <pre><code>def handle_event(self, event: Event):\n\"\"\"Handle event objects, inheriting classes should implement handle_event\"\"\"\n    ...\n</code></pre>"},{"location":"reference/#guitk.window.Window.quit","title":"<code>quit(return_value=None)</code>","text":"<p>Called when closing the window</p> Source code in <code>guitk/window.py</code> <pre><code>@debug_watch\ndef quit(self, return_value: Any = None):\n\"\"\"Called when closing the window\"\"\"\n    # set return value which is returned by run()\n    self._return_value = return_value\n    self._destroy()\n</code></pre>"},{"location":"reference/#guitk.window.Window.remove","title":"<code>remove(key_or_widget)</code>","text":"<p>Remove widget from window and destroy it.</p> Source code in <code>guitk/window.py</code> <pre><code>def remove(self, key_or_widget: Hashable | BaseWidget):\n\"\"\"Remove widget from window and destroy it.\"\"\"\n    for idx, widget in enumerate(self._widgets):\n        debug(f\"{idx=} {widget=} {key_or_widget=}\")\n        if widget == key_or_widget or widget.key == key_or_widget:\n            widget = self._widgets[idx]\n            if widget.parent == self:\n                self._remove(widget)\n            else:\n                widget.parent.remove(widget)\n            return\n    raise ValueError(f\"Widget {key_or_widget} not found in Window\")\n</code></pre>"},{"location":"reference/#guitk.window.Window.setup","title":"<code>setup()</code>","text":"<p>Perform any needed setup for the window. Gets called immediately after init</p> Source code in <code>guitk/window.py</code> <pre><code>def setup(self):\n\"\"\"Perform any needed setup for the window.\n    Gets called immediately after __init__\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#guitk.window.Window.teardown","title":"<code>teardown()</code>","text":"<p>Perform any cleanup before the window closes. Gets called immediately before the window is destroyed</p> Source code in <code>guitk/window.py</code> <pre><code>def teardown(self):\n\"\"\"Perform any cleanup before the window closes.\n    Gets called immediately before the window is destroyed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#hlayout","title":"HLayout","text":"<p>A Layout manager that aligns widgets horizontally</p> Source code in <code>guitk/layout.py</code> <pre><code>class HLayout:\n\"\"\"A Layout manager that aligns widgets horizontally\"\"\"\n\n    def __init__(\n        self,\n        layout: LayoutType = None,\n        *,\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n    ):\n        self._layout_list = layout or []\n        self.index = 0\n        self.valign = valign\n        self.halign = halign\n        self.window = None\n\n        # get the caller's instance so we can set the layout\n        caller_frame = currentframe().f_back\n        with contextlib.suppress(IndexError, KeyError):\n            first_arg = caller_frame.f_code.co_varnames[0]\n            caller_instance = caller_frame.f_locals[first_arg]\n            # determine if the caller is a Window\n            # need to use repr() because we can't import Window here without causing a circular import\n            if \"guitk.window.Window\" in repr(getmro(caller_instance.__class__)):\n                # HLayout is being used in a Window, so set the Window's layout automatically\n                self.window = caller_instance\n                self.window.layout = self\n\n    def append(self, widget: BaseWidget):\n\"\"\"Add a widget to the end of the HLayout\"\"\"\n        if not self.window:\n            # HLayout is not being used in a Window, can't add widget\n            raise RuntimeError(\n                \"Layout must have been created in a Window to add widgets\"\n            )\n        self.window.col_count += 1\n        self.window.add_widget(widget, 0, self.window.col_count)\n\n    def remove(self, key_or_widget: Hashable | BaseWidget):\n\"\"\"Remove widget from layout\" and destroy it.\n\n        Args:\n            key_or_widget (Hashable | Widget): The key or widget to remove. If a key is given,\n                the first widget with that key will be removed.\n\n        Raises:\n            RuntimeError: If called and the layout was not created in a Window.\n            ValueError: If the widget is not found in the layout.\n        \"\"\"\n        if not self.window:\n            raise RuntimeError(\n                \"Layout must have been created in a Window to remove widgets\"\n            )\n        for idx, widget in enumerate(self._layout_list):\n            if widget == key_or_widget or widget.key == key_or_widget:\n                widget = self._layout_list.pop(idx)\n                self.window._forget_widget(widget)\n                widget.widget.grid_forget()\n                widget.widget.destroy()\n                self.window.window.update_idletasks()\n                return\n        raise ValueError(f\"Widget {key_or_widget} not found in Layout\")\n\n    def _add_widget(self, widget):\n\"\"\"Add a widget to the end of the Layout\"\"\"\n        self._layout_list.append(widget)\n\n    @property\n    def layout(self) -&gt; LayoutType:\n\"\"\"Return the layout list\"\"\"\n        # if layout manually created, it will be a list of lists\n        # otherwise it's a row of widgets, so wrap it in a list\n        return (\n            self._layout_list\n            if self._layout_list and isinstance(self._layout_list[0], (list, tuple))\n            else [self._layout_list]\n        )\n\n    def __enter__(self):\n        push_parent(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pop_parent()\n        return False\n\n    def __iter__(self):\n        self.index = 0\n        return iter(self.layout)\n\n    def __next__(self):\n        if self.index &gt;= len(self.layout):\n            raise StopIteration\n        value = self.layout[self.index]\n        self.index += 1\n        return value\n</code></pre>"},{"location":"reference/#guitk.layout.HLayout.layout","title":"<code>layout: LayoutType</code>  <code>property</code>","text":"<p>Return the layout list</p>"},{"location":"reference/#guitk.layout.HLayout.append","title":"<code>append(widget)</code>","text":"<p>Add a widget to the end of the HLayout</p> Source code in <code>guitk/layout.py</code> <pre><code>def append(self, widget: BaseWidget):\n\"\"\"Add a widget to the end of the HLayout\"\"\"\n    if not self.window:\n        # HLayout is not being used in a Window, can't add widget\n        raise RuntimeError(\n            \"Layout must have been created in a Window to add widgets\"\n        )\n    self.window.col_count += 1\n    self.window.add_widget(widget, 0, self.window.col_count)\n</code></pre>"},{"location":"reference/#guitk.layout.HLayout.remove","title":"<code>remove(key_or_widget)</code>","text":"<p>Remove widget from layout\" and destroy it.</p> <p>Parameters:</p> Name Type Description Default <code>key_or_widget</code> <code>Hashable | Widget</code> <p>The key or widget to remove. If a key is given, the first widget with that key will be removed.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called and the layout was not created in a Window.</p> <code>ValueError</code> <p>If the widget is not found in the layout.</p> Source code in <code>guitk/layout.py</code> <pre><code>def remove(self, key_or_widget: Hashable | BaseWidget):\n\"\"\"Remove widget from layout\" and destroy it.\n\n    Args:\n        key_or_widget (Hashable | Widget): The key or widget to remove. If a key is given,\n            the first widget with that key will be removed.\n\n    Raises:\n        RuntimeError: If called and the layout was not created in a Window.\n        ValueError: If the widget is not found in the layout.\n    \"\"\"\n    if not self.window:\n        raise RuntimeError(\n            \"Layout must have been created in a Window to remove widgets\"\n        )\n    for idx, widget in enumerate(self._layout_list):\n        if widget == key_or_widget or widget.key == key_or_widget:\n            widget = self._layout_list.pop(idx)\n            self.window._forget_widget(widget)\n            widget.widget.grid_forget()\n            widget.widget.destroy()\n            self.window.window.update_idletasks()\n            return\n    raise ValueError(f\"Widget {key_or_widget} not found in Layout\")\n</code></pre>"},{"location":"reference/#vlayout","title":"VLayout","text":"<p>         Bases: <code>HLayout</code></p> <p>A Layout manager that aligns widgets vertically</p> Source code in <code>guitk/layout.py</code> <pre><code>class VLayout(HLayout):\n\"\"\"A Layout manager that aligns widgets vertically\"\"\"\n\n    @property\n    def layout(self):\n        return [[w] for w in self._layout_list]\n\n    def append(self, widget: BaseWidget):\n\"\"\"Add a widget to the bottom of the VLayout\"\"\"\n        if not self.window:\n            # HLayout is not being used in a Window, can't add widget\n            raise RuntimeError(\n                \"VLayout must have been created in a Window to add widgets\"\n            )\n        self.window.row_count += 1\n        self.window.add_widget(widget, self.window.row_count, 0)\n</code></pre>"},{"location":"reference/#guitk.layout.VLayout.append","title":"<code>append(widget)</code>","text":"<p>Add a widget to the bottom of the VLayout</p> Source code in <code>guitk/layout.py</code> <pre><code>def append(self, widget: BaseWidget):\n\"\"\"Add a widget to the bottom of the VLayout\"\"\"\n    if not self.window:\n        # HLayout is not being used in a Window, can't add widget\n        raise RuntimeError(\n            \"VLayout must have been created in a Window to add widgets\"\n        )\n    self.window.row_count += 1\n    self.window.add_widget(widget, self.window.row_count, 0)\n</code></pre>"},{"location":"reference/#hstack","title":"HStack","text":"<p>         Bases: <code>_Stack</code></p> <p>A container that stacks widgets horizontally when added to a Layout</p> Source code in <code>guitk/containers.py</code> <pre><code>class HStack(_Stack):\n\"\"\"A container that stacks widgets horizontally when added to a Layout\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        height: int | None = None,\n        padding: PaddingType | None = None,\n        disabled: bool | None = False,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        expand: bool = True,\n        distribute: bool = False,\n        vspacing: PadType | None = None,\n        hspacing: PadType | None = None,\n    ):\n\"\"\"A container that stacks widgets horizontally when added to a Layout\n\n        Args:\n            key (Hashable, optional): The key to use for the HStack. Defaults to None.\n            height (int, optional): The height of the HStack. Defaults to None.\n            padding (PaddingType, optional): The padding around the HStack. Defaults to None.\n            disabled (bool, optional): Whether the HStack is disabled. Defaults to False.\n            sticky (str, optional): The sticky value for the HStack. Defaults to \"nsew\".\n            valign (VAlign, optional): The vertical alignment for the widgets in the HStack.\n                Defaults to None.\n            halign (HAlign, optional): The horizontal alignment for the widgets in the HStack.\n                Defaults to None.\n            expand (bool, optional): Whether the HStack should expand to fill the available space.\n                Defaults to True.\n            distribute (bool, optional): Whether the HStack should distribute widgets evenly.\n            vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n            hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n\n        Note:\n            If height is specified, the HStack will not expand to fill the available space and the\n            expand parameter will be ignored.\n        \"\"\"\n        super().__init__(\n            key=key,\n            height=height,\n            width=None,\n            padding=padding,\n            disabled=disabled,\n            sticky=sticky,\n            valign=valign,\n            halign=halign,\n            expand=expand,\n            distribute=distribute,\n            vspacing=vspacing,\n            hspacing=hspacing,\n        )\n        self.expand = expand if height is None else False\n\n    @property\n    def layout(self) -&gt; list[list[BaseWidget]]:\n\"\"\"Return the layout of the HStack\"\"\"\n        if self.distribute:\n            self._layout_lol = [[]]\n            for widget in self._layout_list:\n                self._layout_lol[0].append(HSpacer())\n                self._layout_lol[0].append(widget)\n            self._layout_lol[0].append(HSpacer())\n        else:\n            self._layout_lol = [self._layout_list]\n        return self._layout_lol\n\n    @layout.setter\n    def layout(self, layout: list[list[BaseWidget]]):\n\"\"\"Set the layout of the VStack\"\"\"\n        self._layout_lol = layout\n        self._layout_list = [widget for row in layout for widget in row]\n\n    @debug_watch\n    def _insert_widget_row_col(\n        self, widget: BaseWidget, row: int, col: int, is_vertical: bool = True\n    ):\n\"\"\"Insert a widget into the container after the container has been created\n            Intended for use at run-time only when widgets need to be added dynamically\n\n        Args:\n            widget: (Widget) the widget to add\n            row: (int) the row to insert the widget into\n            col: (int) the column to insert the widget into\n\n        Note: widgets are placed in a grid with row, col coordinates by the _LayoutMixin class.\n        All containers store widgets internally as a list so we need to convert the row, col\n        coordinates to a list index.\n        \"\"\"\n        super()._insert_widget_row_col(widget, row, col, is_vertical=False)\n</code></pre>"},{"location":"reference/#guitk.containers.HStack.layout","title":"<code>layout: list[list[BaseWidget]]</code>  <code>writable</code> <code>property</code>","text":"<p>Return the layout of the HStack</p>"},{"location":"reference/#guitk.containers.HStack.__init__","title":"<code>__init__(key=None, height=None, padding=None, disabled=False, sticky='nsew', valign=None, halign=None, expand=True, distribute=False, vspacing=None, hspacing=None)</code>","text":"<p>A container that stacks widgets horizontally when added to a Layout</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>The key to use for the HStack. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the HStack. Defaults to None.</p> <code>None</code> <code>padding</code> <code>PaddingType</code> <p>The padding around the HStack. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the HStack is disabled. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str</code> <p>The sticky value for the HStack. Defaults to \"nsew\".</p> <code>'nsew'</code> <code>valign</code> <code>VAlign</code> <p>The vertical alignment for the widgets in the HStack. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign</code> <p>The horizontal alignment for the widgets in the HStack. Defaults to None.</p> <code>None</code> <code>expand</code> <code>bool</code> <p>Whether the HStack should expand to fill the available space. Defaults to True.</p> <code>True</code> <code>distribute</code> <code>bool</code> <p>Whether the HStack should distribute widgets evenly.</p> <code>False</code> <code>vspacing</code> <code>PadType</code> <p>Vertical spacing between widgets. Defaults to None.</p> <code>None</code> <code>hspacing</code> <code>PadType</code> <p>Horizontal spacing between widgets. Defaults to None.</p> <code>None</code> Note <p>If height is specified, the HStack will not expand to fill the available space and the expand parameter will be ignored.</p> Source code in <code>guitk/containers.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    height: int | None = None,\n    padding: PaddingType | None = None,\n    disabled: bool | None = False,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    expand: bool = True,\n    distribute: bool = False,\n    vspacing: PadType | None = None,\n    hspacing: PadType | None = None,\n):\n\"\"\"A container that stacks widgets horizontally when added to a Layout\n\n    Args:\n        key (Hashable, optional): The key to use for the HStack. Defaults to None.\n        height (int, optional): The height of the HStack. Defaults to None.\n        padding (PaddingType, optional): The padding around the HStack. Defaults to None.\n        disabled (bool, optional): Whether the HStack is disabled. Defaults to False.\n        sticky (str, optional): The sticky value for the HStack. Defaults to \"nsew\".\n        valign (VAlign, optional): The vertical alignment for the widgets in the HStack.\n            Defaults to None.\n        halign (HAlign, optional): The horizontal alignment for the widgets in the HStack.\n            Defaults to None.\n        expand (bool, optional): Whether the HStack should expand to fill the available space.\n            Defaults to True.\n        distribute (bool, optional): Whether the HStack should distribute widgets evenly.\n        vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n        hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n\n    Note:\n        If height is specified, the HStack will not expand to fill the available space and the\n        expand parameter will be ignored.\n    \"\"\"\n    super().__init__(\n        key=key,\n        height=height,\n        width=None,\n        padding=padding,\n        disabled=disabled,\n        sticky=sticky,\n        valign=valign,\n        halign=halign,\n        expand=expand,\n        distribute=distribute,\n        vspacing=vspacing,\n        hspacing=hspacing,\n    )\n    self.expand = expand if height is None else False\n</code></pre>"},{"location":"reference/#vstack","title":"VStack","text":"<p>         Bases: <code>_Stack</code></p> <p>A container that stacks widgets vertically when added to a Layout</p> Source code in <code>guitk/containers.py</code> <pre><code>class VStack(_Stack):\n\"\"\"A container that stacks widgets vertically when added to a Layout\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        width: int | None = None,\n        padding: PaddingType | None = None,\n        disabled: bool | None = False,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        expand: bool = True,\n        distribute: bool = False,\n        vspacing: PadType | None = None,\n        hspacing: PadType | None = None,\n    ):\n\"\"\"Base container container that stacks widgets vertically when added to a Layout\n\n        Args:\n            key (Hashable, optional): The key to use for the VStack. Defaults to None.\n            width (int, optional): The width of the VStack. Defaults to None.\n            padding (PaddingType, optional): The padding around the VStack. Defaults to None.\n            disabled (bool, optional): Whether the VStack is disabled. Defaults to False.\n            sticky (str, optional): The sticky value for the VStack. Defaults to \"nsew\".\n            valign (VAlign, optional): The vertical alignment for the widgets in the VStack.\n                Defaults to None.\n            halign (HAlign, optional): The horizontal alignment for the widgets in the VStack.\n                Defaults to None.\n            expand (bool, optional): Whether the VStack should expand to fill the available space.\n                Defaults to True.\n            distribute (bool, optional): Whether the VStack should distribute widgets evenly.\n            vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n            hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n\n        Note:\n            If width is specified, the VStack will not expand to fill the available space and the\n            expand parameter will be ignored.\n        \"\"\"\n        super().__init__(\n            key=key,\n            height=None,\n            width=width,\n            padding=padding,\n            disabled=disabled,\n            sticky=sticky,\n            valign=valign,\n            halign=halign,\n            expand=expand,\n            distribute=distribute,\n            vspacing=vspacing,\n            hspacing=hspacing,\n        )\n        self.expand = expand if width is None else False\n</code></pre>"},{"location":"reference/#guitk.containers.VStack.__init__","title":"<code>__init__(key=None, width=None, padding=None, disabled=False, sticky='nsew', valign=None, halign=None, expand=True, distribute=False, vspacing=None, hspacing=None)</code>","text":"<p>Base container container that stacks widgets vertically when added to a Layout</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>The key to use for the VStack. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the VStack. Defaults to None.</p> <code>None</code> <code>padding</code> <code>PaddingType</code> <p>The padding around the VStack. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the VStack is disabled. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str</code> <p>The sticky value for the VStack. Defaults to \"nsew\".</p> <code>'nsew'</code> <code>valign</code> <code>VAlign</code> <p>The vertical alignment for the widgets in the VStack. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign</code> <p>The horizontal alignment for the widgets in the VStack. Defaults to None.</p> <code>None</code> <code>expand</code> <code>bool</code> <p>Whether the VStack should expand to fill the available space. Defaults to True.</p> <code>True</code> <code>distribute</code> <code>bool</code> <p>Whether the VStack should distribute widgets evenly.</p> <code>False</code> <code>vspacing</code> <code>PadType</code> <p>Vertical spacing between widgets. Defaults to None.</p> <code>None</code> <code>hspacing</code> <code>PadType</code> <p>Horizontal spacing between widgets. Defaults to None.</p> <code>None</code> Note <p>If width is specified, the VStack will not expand to fill the available space and the expand parameter will be ignored.</p> Source code in <code>guitk/containers.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    width: int | None = None,\n    padding: PaddingType | None = None,\n    disabled: bool | None = False,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    expand: bool = True,\n    distribute: bool = False,\n    vspacing: PadType | None = None,\n    hspacing: PadType | None = None,\n):\n\"\"\"Base container container that stacks widgets vertically when added to a Layout\n\n    Args:\n        key (Hashable, optional): The key to use for the VStack. Defaults to None.\n        width (int, optional): The width of the VStack. Defaults to None.\n        padding (PaddingType, optional): The padding around the VStack. Defaults to None.\n        disabled (bool, optional): Whether the VStack is disabled. Defaults to False.\n        sticky (str, optional): The sticky value for the VStack. Defaults to \"nsew\".\n        valign (VAlign, optional): The vertical alignment for the widgets in the VStack.\n            Defaults to None.\n        halign (HAlign, optional): The horizontal alignment for the widgets in the VStack.\n            Defaults to None.\n        expand (bool, optional): Whether the VStack should expand to fill the available space.\n            Defaults to True.\n        distribute (bool, optional): Whether the VStack should distribute widgets evenly.\n        vspacing (PadType, optional): Vertical spacing between widgets. Defaults to None.\n        hspacing (PadType, optional): Horizontal spacing between widgets. Defaults to None.\n\n    Note:\n        If width is specified, the VStack will not expand to fill the available space and the\n        expand parameter will be ignored.\n    \"\"\"\n    super().__init__(\n        key=key,\n        height=None,\n        width=width,\n        padding=padding,\n        disabled=disabled,\n        sticky=sticky,\n        valign=valign,\n        halign=halign,\n        expand=expand,\n        distribute=distribute,\n        vspacing=vspacing,\n        hspacing=hspacing,\n    )\n    self.expand = expand if width is None else False\n</code></pre>"},{"location":"reference/#hspacer","title":"HSpacer","text":"<p>         Bases: <code>Label</code></p> <p>HSpacer widget that expands to fill the horizontal space in the layout</p> Source code in <code>guitk/spacer.py</code> <pre><code>class HSpacer(Label):\n\"\"\"HSpacer widget that expands to fill the horizontal space in the layout\"\"\"\n\n    def __init__(self, rowspan=1):\n        super().__init__(\n            \"\",\n            padding=0,\n            disabled=True,\n            sticky=\"nsew\",\n            autoframe=False,\n            borderwidth=debug_borderwidth() or None,\n            relief=debug_relief() or None,\n            weightx=1,\n            rowspan=rowspan,\n        )\n\n    def _create_widget(self, parent: tk.BaseWidget, window: Window, row: int, col: int):\n        super()._create_widget(parent, window, row, col)\n</code></pre>"},{"location":"reference/#vspacer","title":"VSpacer","text":"<p>         Bases: <code>Label</code></p> <p>\"HSpacer widget that expands to fill the vertical space in the layout</p> Source code in <code>guitk/spacer.py</code> <pre><code>class VSpacer(Label):\n\"\"\" \"HSpacer widget that expands to fill the vertical space in the layout\"\"\"\n\n    def __init__(self, columnspan=1):\n        super().__init__(\n            \"\",\n            padding=0,\n            disabled=True,\n            sticky=\"nsew\",\n            autoframe=False,\n            borderwidth=debug_borderwidth() or None,\n            relief=debug_relief() or None,\n            weighty=1,\n            columnspan=columnspan,\n        )\n\n    def _create_widget(self, parent: tk.BaseWidget, window: Window, row: int, col: int):\n        super()._create_widget(parent, window, row, col)\n</code></pre>"},{"location":"reference/#button","title":"Button","text":"<p>         Bases: <code>BaseWidget</code></p> <p>Basic button</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class Button(BaseWidget):\n\"\"\"Basic button\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        image: str | None = None,\n        key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a Button widget.\n\n        Args:\n            text (str): Text for the button.\n            image (str | None, optional): Image for the button. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n\n        self.widget_type = \"ttk.Button\"\n        self.text = text\n        self.image = image\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tooltip = tooltip\n        self.padx = padx\n        self.pady = pady\n        self.kwargs = kwargs\n\n    @property\n    def value(self) -&gt; str:\n        return self.widget[\"text\"]\n\n    @value.setter\n    def value(self, text: str):\n        self.widget[\"text\"] = text\n\n    def _create_widget(self, parent: Any, window: Window, row: int, col: int):\n\"\"\"Create the ttk.Button widget\"\"\"\n        event = Event(self, window, self.key, EventType.ButtonPress)\n\n        # build arg list for Button()\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n\n        if self.image:\n            self._photoimage = load_image(self.image)\n            kwargs_button[\"image\"] = self._photoimage\n\n        self.widget = ttk.Button(\n            parent,\n            text=self.text,\n            command=window._make_callback(event),\n            **kwargs_button,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ButtonPress,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def button(self):\n\"\"\"Return the Tk button widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_button.Button.button","title":"<code>button</code>  <code>property</code>","text":"<p>Return the Tk button widget</p>"},{"location":"reference/#guitk.ttk_button.Button.__init__","title":"<code>__init__(text, image=None, key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> required <code>image</code> <code>str | None</code> <p>Image for the button. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    image: str | None = None,\n    key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a Button widget.\n\n    Args:\n        text (str): Text for the button.\n        image (str | None, optional): Image for the button. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n\n    self.widget_type = \"ttk.Button\"\n    self.text = text\n    self.image = image\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.tooltip = tooltip\n    self.padx = padx\n    self.pady = pady\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#browsefilebutton","title":"BrowseFileButton","text":"<p>         Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a file.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseFileButton(Button):\n\"\"\"Button that opens a file dialog to select a file.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        filename_only: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize a BrowseFileButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected filename.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseFileButton\"\n        self._filename = None\n        self._filename_only = filename_only\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def filename(self):\n        return self._filename\n\n    def browse_dialog(self):\n\"\"\"Open a file dialog to select a file\"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._filename = filedialog.askopenfilename(**kwargs_options)\n        if self._filename_only and self._filename:\n            # only want the name, not the path\n            self._filename = pathlib.Path(self._filename).name\n        if self.target_key and self._filename:\n            self.window[self.target_key].value = self._filename\n        event = Event(self, self.window, self.key, EventType.BrowseFile)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseFileButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, filename_only=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseFileButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected filename.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>filename_only</code> <code>bool</code> <p>If True, only the filename is returned. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    filename_only: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize a BrowseFileButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected filename.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        filename_only (bool, optional): If True, only the filename is returned. Defaults to False.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseFileButton\"\n    self._filename = None\n    self._filename_only = filename_only\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseFileButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a file</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n\"\"\"Open a file dialog to select a file\"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._filename = filedialog.askopenfilename(**kwargs_options)\n    if self._filename_only and self._filename:\n        # only want the name, not the path\n        self._filename = pathlib.Path(self._filename).name\n    if self.target_key and self._filename:\n        self.window[self.target_key].value = self._filename\n    event = Event(self, self.window, self.key, EventType.BrowseFile)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#browsedirectorybutton","title":"BrowseDirectoryButton","text":"<p>         Bases: <code>Button</code></p> <p>Button that opens a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>class BrowseDirectoryButton(Button):\n\"\"\"Button that opens a file dialog to select a directory.\"\"\"\n\n    def __init__(\n        self,\n        text=\"Browse\",\n        key: Hashable | None = None,\n        target_key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a BrowseDirectoryButton widget.\n\n        Args:\n            text (str): Text for the button.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n                If set, the target widget's value is set to the selected directory.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            weightx (int | None, optional): Weight in x direction. Defaults to None.\n            weighty (int | None, optional): Weight in y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n        \"\"\"\n        super().__init__(\n            text,\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.target_key = target_key\n        self.widget_type = \"guitk.BrowseDirectoryButton\"\n        self._dirname = None\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_button = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_button_attributes\n        }\n        self.widget = ttk.Button(\n            parent, text=self.text, command=self.browse_dialog, **kwargs_button\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def directory(self):\n        return self._dirname\n\n    def browse_dialog(self):\n\"\"\"\n        Open a file dialog to select a directory.\n        \"\"\"\n        kwargs_options = {\n            k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n        }\n        self._dirname = filedialog.askdirectory(**kwargs_options)\n        if self.target_key and self._dirname:\n            self.window[self.target_key].value = self._dirname\n        event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n        self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseDirectoryButton.__init__","title":"<code>__init__(text='Browse', key=None, target_key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a BrowseDirectoryButton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the button.</p> <code>'Browse'</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>target_key</code> <code>Hashable</code> <p>Unique key for the target widget. Defaults to None. If set, the target widget's value is set to the selected directory.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight in x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight in y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.</p> <code>{}</code> Source code in <code>guitk/ttk_button.py</code> <pre><code>def __init__(\n    self,\n    text=\"Browse\",\n    key: Hashable | None = None,\n    target_key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a BrowseDirectoryButton widget.\n\n    Args:\n        text (str): Text for the button.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        target_key (Hashable, optional): Unique key for the target widget. Defaults to None.\n            If set, the target widget's value is set to the selected directory.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        weightx (int | None, optional): Weight in x direction. Defaults to None.\n        weighty (int | None, optional): Weight in y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Button or filedialog.askopenfilename as appropriate.\n    \"\"\"\n    super().__init__(\n        text,\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.target_key = target_key\n    self.widget_type = \"guitk.BrowseDirectoryButton\"\n    self._dirname = None\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_button.BrowseDirectoryButton.browse_dialog","title":"<code>browse_dialog()</code>","text":"<p>Open a file dialog to select a directory.</p> Source code in <code>guitk/ttk_button.py</code> <pre><code>def browse_dialog(self):\n\"\"\"\n    Open a file dialog to select a directory.\n    \"\"\"\n    kwargs_options = {\n        k: v for k, v in self.kwargs.items() if k in _valid_askopenfile_options\n    }\n    self._dirname = filedialog.askdirectory(**kwargs_options)\n    if self.target_key and self._dirname:\n        self.window[self.target_key].value = self._dirname\n    event = Event(self, self.window, self.key, EventType.BrowseDirectory)\n    self.window._handle_event(event)\n</code></pre>"},{"location":"reference/#checkbutton","title":"Checkbutton","text":"<p>         Bases: <code>BaseWidget</code></p> <p>Checkbox / checkbutton</p> Source code in <code>guitk/ttk_checkbutton.py</code> <pre><code>class Checkbutton(BaseWidget):\n\"\"\"Checkbox / checkbutton\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        checked: bool = False,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a ttk.Checkbutton widget.\n\n        Args:\n            text (str): Text for the checkbutton.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            checked (bool, optional): Initial state. Defaults to False (not checked).\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n            weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n\n        Notes:\n            Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Checkbutton\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self._value: tk.BooleanVar = tk.BooleanVar()\n        self._checked = checked\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        event = Event(self, window, self.key, EventType.Checkbutton)\n\n        # build arg list for Checkbutton\n        kwargs_checkbutton = {\n            k: v\n            for k, v in self.kwargs.items()\n            if k in _valid_ttk_checkbutton_attributes\n        }\n\n        self.widget = ttk.Checkbutton(\n            parent,\n            text=self.text,\n            anchor=self.kwargs.get(\"anchor\"),\n            command=window._make_callback(event),\n            variable=self._value,\n            onvalue=True,\n            **kwargs_checkbutton,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.Checkbutton,\n                    command=self._command,\n                )\n            )\n\n        if self._checked:\n            self.widget.invoke()\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n        return self.widget\n\n    @property\n    def checkbutton(self):\n\"\"\"Return the ttk.Checkbutton widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_checkbutton.Checkbutton.checkbutton","title":"<code>checkbutton</code>  <code>property</code>","text":"<p>Return the ttk.Checkbutton widget</p>"},{"location":"reference/#guitk.ttk_checkbutton.Checkbutton.__init__","title":"<code>__init__(text, key=None, checked=False, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=True, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a ttk.Checkbutton widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text for the checkbutton.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>checked</code> <code>bool</code> <p>Initial state. Defaults to False (not checked).</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>True</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight of widget in X direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of widget in Y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Checkbutton.</p> <code>{}</code> Notes <p>Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False.</p> Source code in <code>guitk/ttk_checkbutton.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    checked: bool = False,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = True,\n    sticky: str | None = None,\n    tooltip: TooltipType | None = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a ttk.Checkbutton widget.\n\n    Args:\n        text (str): Text for the checkbutton.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        checked (bool, optional): Initial state. Defaults to False (not checked).\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n        weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n\n    Notes:\n        Unlike a regular ttk.Checkbutton, the onvalue and offvalue are always True and False.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Checkbutton\"\n    self.text = text\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self._value: tk.BooleanVar = tk.BooleanVar()\n    self._checked = checked\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#combobox","title":"Combobox","text":"<p>         Bases: <code>BaseWidget</code></p> <p>ttk Combobox</p> Source code in <code>guitk/ttk_combobox.py</code> <pre><code>class Combobox(BaseWidget):\n\"\"\"ttk Combobox\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        default: str | None = None,\n        values: list[str] | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = True,\n        sticky: str | None = None,\n        tooltip: TooltipType | None = None,\n        command: CommandType | None = None,\n        readonly: bool = False,\n        autosize: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n\"\"\"\n        Initialize a ttk.Combobox widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str, optional): Default value. Defaults to None.\n            values (list[str], optional): List of values for the combobox. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            readonly (bool, optional): If True, widget is read-only. Defaults to False.\n                If Combobox is not readonly, user can type in a value that is not in the list of values.\n            autosize (bool, optional): If True, automatically set width to fit longest value. Defaults to False.\n            weightx (int | None, optional): Weight of widget in X direction. Defaults to None.\n            weighty (int | None, optional): Weight of widget in Y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Checkbutton.\n        \"\"\"\n        self.widget_type = \"ttk.Combobox\"\n        self.key = key or \"Combobox\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self._readonly = readonly\n        self._autosize = autosize\n        self.kwargs = kwargs\n        self.values = values\n        self.default = default\n\n    def _create_widget(self, parent, window: Window, row, col):\n        # build arg list for Combobox\n        kwargs = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_combobox_attributes\n        }\n\n        if self._autosize:\n            # automatically set width, override any width value provided\n            width = len(max(self.values, key=len))\n            kwargs[\"width\"] = width + 1\n\n        self.widget = ttk.Combobox(\n            parent,\n            textvariable=self._value,\n            values=self.values,\n            **kwargs,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event_release = Event(self.widget, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event_release))\n\n        event_selected = Event(\n            self.widget, window, self.key, EventType.ComboboxSelected\n        )\n        self.widget.bind(\"&lt;&lt;ComboboxSelected&gt;&gt;\", window._make_callback(event_selected))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.ComboboxSelected,\n                    command=self._command,\n                )\n            )\n\n        if self.default is not None:\n            self.value = self.default\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        if self._readonly:\n            self.widget.state([\"readonly\"])\n\n        return self.widget\n\n    @property\n    def combobox(self):\n\"\"\"Return the Tk combobox widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_combobox.Combobox.combobox","title":"<code>combobox</code>  <code>property</code>","text":"<p>Return the Tk combobox widget</p>"},{"location":"reference/#entry","title":"Entry","text":"<p>         Bases: <code>BaseWidget</code></p> <p>ttk.Entry text entry / input box</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class Entry(BaseWidget):\n\"\"\"ttk.Entry text entry / input box\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize an Entry widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Entry\"\n        default = default or \"\"\n        self._value.set(default)\n        self.key = key or \"Entry\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.hscrollbar = hscrollbar\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n        # build arg list for ttk.Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            ttk.Entry,\n            hscrollbar=self.hscrollbar,\n            textvariable=self._value,\n            **kwargs_entry,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n\"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_entry.Entry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.ttk_entry.Entry.__init__","title":"<code>__init__(key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize an Entry widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Entry\"\n    default = default or \"\"\n    self._value.set(default)\n    self.key = key or \"Entry\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.hscrollbar = hscrollbar\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#labelentry","title":"LabelEntry","text":"<p>         Bases: <code>Entry</code></p> <p>Text entry / input box with a label</p> Source code in <code>guitk/ttk_entry.py</code> <pre><code>class LabelEntry(Entry):\n\"\"\"Text entry / input box with a label\"\"\"\n\n    # TODO: add option to put label above the entry box\n\n    def __init__(\n        self,\n        text: str,\n        key: Hashable | None = None,\n        default: str | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize an Entry widget.\n\n        Args:\n            text (str): Label text.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            default (str | None, optional): Default text for the entry box. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n            weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n            focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            default=default,\n            disabled=disabled,\n            columnspan=columnspan,\n            rowspan=rowspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            hscrollbar=hscrollbar,\n            focus=focus,\n            weightx=weightx,\n            weighty=weighty,\n        )\n        self.widget_type = \"guitk.LabelEntry\"\n        self.text = text\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        # build arg list for Entry\n        kwargs_entry = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_entry_attributes\n        }\n        self.widget = _ttkLabelEntry(\n            parent, text=self.text, textvariable=self._value, **kwargs_entry\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        # bind key release event\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        # bind return key event\n        entry_return_key = Event(self, window, self.key, EventType.EntryReturn)\n        self.widget.bind(\"&lt;Return&gt;\", window._make_callback(entry_return_key))\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def entry(self):\n\"\"\"Return the Tk entry widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_entry.LabelEntry.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>Return the Tk entry widget</p>"},{"location":"reference/#guitk.ttk_entry.LabelEntry.__init__","title":"<code>__init__(text, key=None, default=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Entry widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Label text.</p> required <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>default</code> <code>str | None</code> <p>Default text for the entry box. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight for horizontal resizing. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight for vertical resizing. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget will have focus. Defaults to False. Only one widget can have focus.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_entry.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    key: Hashable | None = None,\n    default: str | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize an Entry widget.\n\n    Args:\n        text (str): Label text.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        default (str | None, optional): Default text for the entry box. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight for horizontal resizing. Defaults to None.\n        weighty (int | None, optional): Weight for vertical resizing. Defaults to None.\n        focus (bool, optional): If True, widget will have focus. Defaults to False. Only one widget can have focus.\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        default=default,\n        disabled=disabled,\n        columnspan=columnspan,\n        rowspan=rowspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        hscrollbar=hscrollbar,\n        focus=focus,\n        weightx=weightx,\n        weighty=weighty,\n    )\n    self.widget_type = \"guitk.LabelEntry\"\n    self.text = text\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#label","title":"Label","text":"<p>         Bases: <code>BaseWidget</code></p> <p>ttk.Label widget</p> Source code in <code>guitk/ttk_label.py</code> <pre><code>class Label(BaseWidget):\n\"\"\"ttk.Label widget\"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        image: str | None = None,\n        key: Hashable | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a Label widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            text (str): Text to display in the label.\n            image: (str, optional): Path to image to display in the label. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            weightx (int | None, optional): Weight of this widget in the horizontal direction. Defaults to None.\n            weighty (int | None, optional): Weight of this widget in the vertical direction. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            weightx=weightx,\n            weighty=weighty,\n        )\n        self.widget_type = \"ttk.Label\"\n        self.text = text\n        self.key = key or text\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.image = image\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: Window, row, col):\n\"\"\"Create the ttk.Label widget\"\"\"\n\n        # Arg list for ttk.Label\n        kwargs_label = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_label_attributes\n        }\n\n        if self.image:\n            self._photoimage = load_image(self.image)\n            kwargs_label[\"image\"] = self._photoimage\n\n        self.widget = ttk.Label(\n            parent,\n            text=self.text,\n            **kwargs_label,\n        )\n        self.widget[\"textvariable\"] = self._value\n        self._value.set(self.text)\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n        return self.widget\n\n    @property\n    def label(self):\n\"\"\"Return the Tk label widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_label.Label.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the Tk label widget</p>"},{"location":"reference/#guitk.ttk_label.Label.__init__","title":"<code>__init__(text, image=None, key=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, weightx=None, weighty=None, **kwargs)</code>","text":"<p>Initialize a Label widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>text</code> <code>str</code> <p>Text to display in the label.</p> required <code>image</code> <code>str | None</code> <p>(str, optional): Path to image to display in the label. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Weight of this widget in the horizontal direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of this widget in the vertical direction. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_label.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    image: str | None = None,\n    key: Hashable | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    **kwargs,\n):\n\"\"\"\n    Initialize a Label widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        text (str): Text to display in the label.\n        image: (str, optional): Path to image to display in the label. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        weightx (int | None, optional): Weight of this widget in the horizontal direction. Defaults to None.\n        weighty (int | None, optional): Weight of this widget in the vertical direction. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        weightx=weightx,\n        weighty=weighty,\n    )\n    self.widget_type = \"ttk.Label\"\n    self.text = text\n    self.key = key or text\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.image = image\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#notebook","title":"Notebook","text":"<p>         Bases: <code>_Container</code></p> <p>ttk.Notebook widget</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class Notebook(_Container):\n\"\"\"ttk.Notebook widget\"\"\"\n\n    def __init__(\n        self,\n        key: Hashable | None = None,\n        tabs: list[HTab] | None = None,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"Initialize a Notebook widget.\n\n        Args:\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            tabs: (list[Tab], optional): Tabs to add to the notebook. Defaults to None.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command to execute when clicked. Defaults to None.\n            weightx (int | None, optional): Horizontal weight. Defaults to None.\n            weighty (int | None, optional): Vertical weight. Defaults to None.\n            focus (bool, optional): If True, widget will have focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to ttk.Entry.\n        \"\"\"\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=disabled,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=False,\n            padx=0,\n            pady=0,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"ttk.Notebook\"\n        self.key = key or \"Notebook\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.tabs = tabs or []\n        self._command = command\n        self.kwargs = kwargs\n        self._tab_count = 0\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        # Arg list for ttk.Label\n        kwargs_notebook = {\n            k: v for k, v in self.kwargs.items() if k in _valid_ttk_notebook_attributes\n        }\n\n        self.widget = ttk.Notebook(parent, **kwargs_notebook)\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event_tab_change = Event(\n            self.widget, window, self.key, EventType.NotebookTabChanged\n        )\n        self.widget.bind(\n            \"&lt;&lt;NotebookTabChanged&gt;&gt;\", window._make_callback(event_tab_change)\n        )\n\n        if self.layout:\n            for row in self.layout:\n                for tab in row:\n                    self.add(tab)\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                # the actual widget will be a tk widget in form widget=.!toplevel.!frame.!notebook, so it won't match self.widget\n                # so set widget=None or _handle_commands won't correctly handle the command\n                EventCommand(\n                    widget=None,\n                    key=self.key,\n                    event_type=EventType.NotebookTabChanged,\n                    command=self._command,\n                )\n            )\n\n        if self.width or self.height:\n            self.widget.grid_propagate(0)\n\n        if self._disabled:\n            self.widget.state([\"disabled\"])\n\n        return self.widget\n\n    @property\n    def current_tab(self):\n\"\"\"Return the name of the currently selected tab\"\"\"\n        return self.notebook.tab(self.notebook.select(), \"text\")\n\n    def add(self, tab: HTab):\n\"\"\"Add a Tab to the Notebook as new tab\"\"\"\n        tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n        tab.kwargs[\"text\"] = tab.name\n        self.notebook.add(tab_, **tab.kwargs)\n\n    def insert(self, pos, tab: HTab):\n\"\"\"Insert a layout to the Notebook as new tab at position pos\"\"\"\n        tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n        tab.kwargs[\"text\"] = tab.name\n        self.notebook.insert(pos, tab_, **tab.kwargs)\n\n    @property\n    def notebook(self):\n\"\"\"Return the ttk.Notebook widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.ttk_notebook.Notebook.current_tab","title":"<code>current_tab</code>  <code>property</code>","text":"<p>Return the name of the currently selected tab</p>"},{"location":"reference/#guitk.ttk_notebook.Notebook.notebook","title":"<code>notebook</code>  <code>property</code>","text":"<p>Return the ttk.Notebook widget</p>"},{"location":"reference/#guitk.ttk_notebook.Notebook.__init__","title":"<code>__init__(key=None, tabs=None, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Notebook widget.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>tabs</code> <code>list[HTab] | None</code> <p>(list[Tab], optional): Tabs to add to the notebook. Defaults to None.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command to execute when clicked. Defaults to None.</p> <code>None</code> <code>weightx</code> <code>int | None</code> <p>Horizontal weight. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Vertical weight. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget will have focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Entry.</p> <code>{}</code> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    key: Hashable | None = None,\n    tabs: list[HTab] | None = None,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"Initialize a Notebook widget.\n\n    Args:\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        tabs: (list[Tab], optional): Tabs to add to the notebook. Defaults to None.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command to execute when clicked. Defaults to None.\n        weightx (int | None, optional): Horizontal weight. Defaults to None.\n        weighty (int | None, optional): Vertical weight. Defaults to None.\n        focus (bool, optional): If True, widget will have focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to ttk.Entry.\n    \"\"\"\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=disabled,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=False,\n        padx=0,\n        pady=0,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"ttk.Notebook\"\n    self.key = key or \"Notebook\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.tabs = tabs or []\n    self._command = command\n    self.kwargs = kwargs\n    self._tab_count = 0\n</code></pre>"},{"location":"reference/#guitk.ttk_notebook.Notebook.add","title":"<code>add(tab)</code>","text":"<p>Add a Tab to the Notebook as new tab</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def add(self, tab: HTab):\n\"\"\"Add a Tab to the Notebook as new tab\"\"\"\n    tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n    tab.kwargs[\"text\"] = tab.name\n    self.notebook.add(tab_, **tab.kwargs)\n</code></pre>"},{"location":"reference/#guitk.ttk_notebook.Notebook.insert","title":"<code>insert(pos, tab)</code>","text":"<p>Insert a layout to the Notebook as new tab at position pos</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def insert(self, pos, tab: HTab):\n\"\"\"Insert a layout to the Notebook as new tab at position pos\"\"\"\n    tab_ = tab._create_widget(self.widget, self.window, 0, 0)\n    tab.kwargs[\"text\"] = tab.name\n    self.notebook.insert(pos, tab_, **tab.kwargs)\n</code></pre>"},{"location":"reference/#htab","title":"HTab","text":"<p>         Bases: <code>_Container</code></p> <p>Tab for Notebook widget that arranges its widgets horizontally</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class HTab(_Container):\n\"\"\"Tab for Notebook widget that arranges its widgets horizontally\"\"\"\n\n    def __init__(\n        self,\n        name=None,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        **kwargs,\n    ):\n\"\"\"Initialize a horizontal Tab\n\n        Args:\n            name (str, optional): Name of the tab. Defaults to None.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n            halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Frame.\n        \"\"\"\n\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=False,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=True,\n            valign=valign,\n            halign=halign,\n            padx=0,\n            pady=0,\n        )\n        self.name = name\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_notebook.HTab.__init__","title":"<code>__init__(name=None, sticky='nsew', valign=None, halign=None, **kwargs)</code>","text":"<p>Initialize a horizontal Tab</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tab. Defaults to None.</p> <code>None</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>'nsew'</code> <code>valign</code> <code>VAlign | None</code> <p>Vertical alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign | None</code> <p>Horizontal alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Frame.</p> <code>{}</code> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    **kwargs,\n):\n\"\"\"Initialize a horizontal Tab\n\n    Args:\n        name (str, optional): Name of the tab. Defaults to None.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n        halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Frame.\n    \"\"\"\n\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=False,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=True,\n        valign=valign,\n        halign=halign,\n        padx=0,\n        pady=0,\n    )\n    self.name = name\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#vtab","title":"VTab","text":"<p>         Bases: <code>HTab</code>, <code>_VerticalContainer</code></p> <p>Tab for Notebook widget that arranges its widgets vertically</p> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>class VTab(HTab, _VerticalContainer):\n\"\"\"Tab for Notebook widget that arranges its widgets vertically\"\"\"\n\n    def __init__(\n        self,\n        name=None,\n        sticky: str | None = \"nsew\",\n        valign: VAlign | None = None,\n        halign: HAlign | None = None,\n        **kwargs,\n    ):\n\"\"\"Initialize a vertical Tab\n\n        Args:\n            name (str, optional): Name of the tab. Defaults to None.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n            halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n            **kwargs: Additional keyword arguments are passed to ttk.Frame.\n        \"\"\"\n\n        super().__init__(\n            frametype=GUITK.ELEMENT_FRAME,\n            key=None,\n            width=None,\n            height=None,\n            layout=None,\n            style=None,\n            borderwidth=None,\n            padding=0,\n            relief=None,\n            disabled=False,\n            rowspan=None,\n            columnspan=None,\n            sticky=sticky,\n            tooltip=None,\n            autoframe=True,\n            padx=0,\n            pady=0,\n            valign=valign,\n            halign=halign,\n        )\n        self.name = name\n        self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#guitk.ttk_notebook.VTab.__init__","title":"<code>__init__(name=None, sticky='nsew', valign=None, halign=None, **kwargs)</code>","text":"<p>Initialize a vertical Tab</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tab. Defaults to None.</p> <code>None</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>'nsew'</code> <code>valign</code> <code>VAlign | None</code> <p>Vertical alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>halign</code> <code>HAlign | None</code> <p>Horizontal alignment of widgets in the tab. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to ttk.Frame.</p> <code>{}</code> Source code in <code>guitk/ttk_notebook.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    sticky: str | None = \"nsew\",\n    valign: VAlign | None = None,\n    halign: HAlign | None = None,\n    **kwargs,\n):\n\"\"\"Initialize a vertical Tab\n\n    Args:\n        name (str, optional): Name of the tab. Defaults to None.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        valign (VAlign | None, optional): Vertical alignment of widgets in the tab. Defaults to None.\n        halign (HAlign | None, optional): Horizontal alignment of widgets in the tab. Defaults to None.\n        **kwargs: Additional keyword arguments are passed to ttk.Frame.\n    \"\"\"\n\n    super().__init__(\n        frametype=GUITK.ELEMENT_FRAME,\n        key=None,\n        width=None,\n        height=None,\n        layout=None,\n        style=None,\n        borderwidth=None,\n        padding=0,\n        relief=None,\n        disabled=False,\n        rowspan=None,\n        columnspan=None,\n        sticky=sticky,\n        tooltip=None,\n        autoframe=True,\n        padx=0,\n        pady=0,\n        valign=valign,\n        halign=halign,\n    )\n    self.name = name\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#text","title":"Text","text":"<p>         Bases: <code>BaseWidget</code></p> <p>A tk Text box</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Text(BaseWidget):\n\"\"\"A tk Text box\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        command: CommandType | None = None,\n        vscrollbar: bool = False,\n        hscrollbar: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize a Text widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n        \"\"\"\n        super().__init__(\n            key=key,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            command=command,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n        )\n        self.widget_type = \"tk.Text\"\n        self.key = key or \"Text\"\n        self.width = width\n        self.height = height\n        self._value = text if text is not None else \"\"\n        self.columnspan = columnspan\n        self.rowspan = rowspan\n        self.vscrollbar = vscrollbar\n        self.hscrollbar = hscrollbar\n        self.kwargs = kwargs\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        kwargs_text = {\n            k: v for k, v in self.kwargs.items() if k in _valid_tk_text_attributes\n        }\n        self.widget = scrolled_widget_factory(\n            parent,\n            tk.Text,\n            vscrollbar=self.vscrollbar,\n            hscrollbar=self.hscrollbar,\n            width=self.width,\n            height=self.height,\n            **kwargs_text,\n        )\n        self._grid(\n            row=row, column=col, rowspan=self.rowspan, columnspan=self.columnspan\n        )\n\n        event = Event(self, window, self.key, EventType.KeyRelease)\n        self.widget.bind(\"&lt;KeyRelease&gt;\", window._make_callback(event))\n\n        self.value = self._value\n\n        if self._command:\n            self.events = True\n            window._bind_command(\n                EventCommand(\n                    widget=self,\n                    key=self.key,\n                    event_type=EventType.KeyRelease,\n                    command=self._command,\n                )\n            )\n\n        if self._disabled:\n            self.widget[\"state\"] = \"disabled\"\n\n        return self.widget\n\n    @property\n    def value(self):\n        return self.widget.get(\"1.0\", tk.END).rstrip()\n\n    @value.setter\n    def value(self, text):\n        self.widget.delete(\"1.0\", tk.END)\n        self.widget.insert(\"1.0\", text)\n\n    @property\n    def text(self):\n\"\"\"Return the Tk text widget\"\"\"\n        return self.widget\n</code></pre>"},{"location":"reference/#guitk.tk_text.Text.text","title":"<code>text</code>  <code>property</code>","text":"<p>Return the Tk text widget</p>"},{"location":"reference/#guitk.tk_text.Text.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, command=None, vscrollbar=False, hscrollbar=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize a Text widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> <code>None</code> <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>False</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    command: CommandType | None = None,\n    vscrollbar: bool = False,\n    hscrollbar: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize a Text widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n    \"\"\"\n    super().__init__(\n        key=key,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        command=command,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n    )\n    self.widget_type = \"tk.Text\"\n    self.key = key or \"Text\"\n    self.width = width\n    self.height = height\n    self._value = text if text is not None else \"\"\n    self.columnspan = columnspan\n    self.rowspan = rowspan\n    self.vscrollbar = vscrollbar\n    self.hscrollbar = hscrollbar\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/#output","title":"Output","text":"<p>         Bases: <code>Text</code></p> <p>Text box that redirects stderr and/or stdout to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>class Output(Text):\n\"\"\"Text box that redirects stderr and/or stdout to the text box.\"\"\"\n\n    def __init__(\n        self,\n        text: str | None = None,\n        key: Hashable | None = None,\n        width: int = 40,\n        height: int = 20,\n        disabled: bool = False,\n        columnspan: int | None = None,\n        rowspan: int | None = None,\n        padx: PadType | None = None,\n        pady: PadType | None = None,\n        events: bool = False,\n        sticky: str | None = None,\n        tooltip: TooltipType = None,\n        vscrollbar: bool = True,\n        hscrollbar: bool = False,\n        stdout: bool = True,\n        stderr: bool = True,\n        echo: bool = False,\n        weightx: int | None = None,\n        weighty: int | None = None,\n        focus: bool = False,\n        **kwargs,\n    ):\n\"\"\"\n        Initialize an Output widget.\n\n        Args:\n            text (str | None, optional): Default text for the text box. Defaults to None.\n            key (Hashable, optional): Unique key for this widget. Defaults to None.\n            width (int, optional): Width of the text box. Defaults to 40.\n            height (int, optional): Height of the text box. Defaults to 20.\n            disabled (bool, optional): If True, widget is disabled. Defaults to False.\n            columnspan (int | None, optional): Number of columns to span. Defaults to None.\n            rowspan (int | None, optional): Number of rows to span. Defaults to None.\n            padx (PadType | None, optional): X padding. Defaults to None.\n            pady (PadType | None, optional): Y padding. Defaults to None.\n            events (bool, optional): Enable events for this widget. Defaults to False.\n            sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n            tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n            command (CommandType | None, optional): Command callback. Defaults to None.\n            vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n            hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n            stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n            stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n            echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n            weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n            weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n            focus (bool, optional): If True, widget has focus. Defaults to False.\n                Only one widget in a window can have focus.HLayout\n            **kwargs: Additional keyword arguments are passed to tk Text.\n        \"\"\"\n        super().__init__(\n            text=text,\n            key=key,\n            width=width,\n            height=height,\n            disabled=disabled,\n            rowspan=rowspan,\n            columnspan=columnspan,\n            padx=padx,\n            pady=pady,\n            events=events,\n            sticky=sticky,\n            tooltip=tooltip,\n            vscrollbar=vscrollbar,\n            hscrollbar=hscrollbar,\n            weightx=weightx,\n            weighty=weighty,\n            focus=focus,\n            **kwargs,\n        )\n\n        self.kwargs = kwargs\n        self._echo = echo\n        self._stdout = stdout\n        self._stderr = stderr\n\n        # stores state for stdout and stderr redirection\n        self._redirect = []\n        self._redirect_id = {}\n\n    def _create_widget(self, parent, window: \"Window\", row, col):\n        self.widget = super()._create_widget(parent, window, row, col)\n\n        # Unbind &lt;KeyRelease&gt; since this isn't for user input\n        self.widget.unbind(\"&lt;KeyRelease&gt;\")\n\n        if self.events:\n            event = Event(self, window, self.key, EventType.OutputWrite)\n            self.window.root.bind_all(\n                EventType.OutputWrite.value, window._make_callback(event)\n            )\n\n        self._configure_redirect()\n        self.enable_redirect()\n\n        return self.widget\n\n    def _configure_redirect(self):\n\"\"\"Configure stdout and stderr redirection.\"\"\"\n        if self._stdout:\n            self._redirect.append(StdOutRedirect())\n        if self._stderr:\n            self._redirect.append(StdErrRedirect())\n        for r in self._redirect:\n            r.echo = self._echo\n            self._redirect_id[r] = r.register(self._write)\n\n    def _write(self, line):\n        self.text.insert(tk.END, line)\n        self.text.yview(tk.END)\n        self.window.root.event_generate(EventType.OutputWrite.value)\n\n    @property\n    def echo(self):\n\"\"\"Return True if stdout and stderr are echoed to the console.\"\"\"\n        return self._echo\n\n    @echo.setter\n    def echo(self, echo):\n\"\"\"Set whether stdout and stderr are echoed to the console.\"\"\"\n        self._echo = echo\n        for r in self._redirect:\n            r.echo = echo\n\n    def disable_redirect(self):\n\"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.disable_redirect()\n\n    def enable_redirect(self):\n\"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n        for r in self._redirect:\n            r.enable_redirect()\n\n    def __del__(self):\n        for r, id_ in self._redirect_id.items():\n            r.deregister(id_)\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.echo","title":"<code>echo</code>  <code>writable</code> <code>property</code>","text":"<p>Return True if stdout and stderr are echoed to the console.</p>"},{"location":"reference/#guitk.tk_text.Output.__init__","title":"<code>__init__(text=None, key=None, width=40, height=20, disabled=False, columnspan=None, rowspan=None, padx=None, pady=None, events=False, sticky=None, tooltip=None, vscrollbar=True, hscrollbar=False, stdout=True, stderr=True, echo=False, weightx=None, weighty=None, focus=False, **kwargs)</code>","text":"<p>Initialize an Output widget.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Default text for the text box. Defaults to None.</p> <code>None</code> <code>key</code> <code>Hashable</code> <p>Unique key for this widget. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the text box. Defaults to 40.</p> <code>40</code> <code>height</code> <code>int</code> <p>Height of the text box. Defaults to 20.</p> <code>20</code> <code>disabled</code> <code>bool</code> <p>If True, widget is disabled. Defaults to False.</p> <code>False</code> <code>columnspan</code> <code>int | None</code> <p>Number of columns to span. Defaults to None.</p> <code>None</code> <code>rowspan</code> <code>int | None</code> <p>Number of rows to span. Defaults to None.</p> <code>None</code> <code>padx</code> <code>PadType | None</code> <p>X padding. Defaults to None.</p> <code>None</code> <code>pady</code> <code>PadType | None</code> <p>Y padding. Defaults to None.</p> <code>None</code> <code>events</code> <code>bool</code> <p>Enable events for this widget. Defaults to False.</p> <code>False</code> <code>sticky</code> <code>str | None</code> <p>Sticky direction for widget layout. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>TooltipType | None</code> <p>Tooltip text or callback to generate tooltip text. Defaults to None.</p> <code>None</code> <code>command</code> <code>CommandType | None</code> <p>Command callback. Defaults to None.</p> required <code>vscrollbar</code> <code>bool</code> <p>Show vertical scrollbar. Defaults to False.</p> <code>True</code> <code>hscrollbar</code> <code>bool</code> <p>Show horizontal scrollbar. Defaults to False.</p> <code>False</code> <code>stdout</code> <code>bool</code> <p>Redirect stdout to the text box. Defaults to True.</p> <code>True</code> <code>stderr</code> <code>bool</code> <p>Redirect stderr to the text box. Defaults to True.</p> <code>True</code> <code>echo</code> <code>bool</code> <p>Echo stdout and stderr to the console. Defaults to False.</p> <code>False</code> <code>weightx</code> <code>int | None</code> <p>Weight of the widget in the x direction. Defaults to None.</p> <code>None</code> <code>weighty</code> <code>int | None</code> <p>Weight of the widget in the y direction. Defaults to None.</p> <code>None</code> <code>focus</code> <code>bool</code> <p>If True, widget has focus. Defaults to False. Only one widget in a window can have focus.HLayout</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments are passed to tk Text.</p> <code>{}</code> Source code in <code>guitk/tk_text.py</code> <pre><code>def __init__(\n    self,\n    text: str | None = None,\n    key: Hashable | None = None,\n    width: int = 40,\n    height: int = 20,\n    disabled: bool = False,\n    columnspan: int | None = None,\n    rowspan: int | None = None,\n    padx: PadType | None = None,\n    pady: PadType | None = None,\n    events: bool = False,\n    sticky: str | None = None,\n    tooltip: TooltipType = None,\n    vscrollbar: bool = True,\n    hscrollbar: bool = False,\n    stdout: bool = True,\n    stderr: bool = True,\n    echo: bool = False,\n    weightx: int | None = None,\n    weighty: int | None = None,\n    focus: bool = False,\n    **kwargs,\n):\n\"\"\"\n    Initialize an Output widget.\n\n    Args:\n        text (str | None, optional): Default text for the text box. Defaults to None.\n        key (Hashable, optional): Unique key for this widget. Defaults to None.\n        width (int, optional): Width of the text box. Defaults to 40.\n        height (int, optional): Height of the text box. Defaults to 20.\n        disabled (bool, optional): If True, widget is disabled. Defaults to False.\n        columnspan (int | None, optional): Number of columns to span. Defaults to None.\n        rowspan (int | None, optional): Number of rows to span. Defaults to None.\n        padx (PadType | None, optional): X padding. Defaults to None.\n        pady (PadType | None, optional): Y padding. Defaults to None.\n        events (bool, optional): Enable events for this widget. Defaults to False.\n        sticky (str | None, optional): Sticky direction for widget layout. Defaults to None.\n        tooltip (TooltipType | None, optional): Tooltip text or callback to generate tooltip text. Defaults to None.\n        command (CommandType | None, optional): Command callback. Defaults to None.\n        vscrollbar (bool, optional): Show vertical scrollbar. Defaults to False.\n        hscrollbar (bool, optional): Show horizontal scrollbar. Defaults to False.\n        stdout (bool, optional): Redirect stdout to the text box. Defaults to True.\n        stderr (bool, optional): Redirect stderr to the text box. Defaults to True.\n        echo (bool, optional): Echo stdout and stderr to the console. Defaults to False.\n        weightx (int | None, optional): Weight of the widget in the x direction. Defaults to None.\n        weighty (int | None, optional): Weight of the widget in the y direction. Defaults to None.\n        focus (bool, optional): If True, widget has focus. Defaults to False.\n            Only one widget in a window can have focus.HLayout\n        **kwargs: Additional keyword arguments are passed to tk Text.\n    \"\"\"\n    super().__init__(\n        text=text,\n        key=key,\n        width=width,\n        height=height,\n        disabled=disabled,\n        rowspan=rowspan,\n        columnspan=columnspan,\n        padx=padx,\n        pady=pady,\n        events=events,\n        sticky=sticky,\n        tooltip=tooltip,\n        vscrollbar=vscrollbar,\n        hscrollbar=hscrollbar,\n        weightx=weightx,\n        weighty=weighty,\n        focus=focus,\n        **kwargs,\n    )\n\n    self.kwargs = kwargs\n    self._echo = echo\n    self._stdout = stdout\n    self._stderr = stderr\n\n    # stores state for stdout and stderr redirection\n    self._redirect = []\n    self._redirect_id = {}\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.disable_redirect","title":"<code>disable_redirect()</code>","text":"<p>Disable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def disable_redirect(self):\n\"\"\"Disable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.disable_redirect()\n</code></pre>"},{"location":"reference/#guitk.tk_text.Output.enable_redirect","title":"<code>enable_redirect()</code>","text":"<p>Enable redirecting stdout and stderr to the text box.</p> Source code in <code>guitk/tk_text.py</code> <pre><code>def enable_redirect(self):\n\"\"\"Enable redirecting stdout and stderr to the text box.\"\"\"\n    for r in self._redirect:\n        r.enable_redirect()\n</code></pre>"}]}